<!DOCTYPE html>
<html lang="en">
<head prefix="og: http://ogp.me/ns#">
  <meta charset="utf-8">
  <title>ContourTriangulator | vtk.js</title>
  <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <!-- Canonical links -->
  <link rel="canonical" href="https://kitware.github.io/vtk-js/api/Filters_General_ContourTriangulator.html">
  <!-- Alternative links -->
  
    
      <link rel="alternative" hreflang="en" href="https://kitware.github.io/vtk-js/api/Filters_General_ContourTriangulator.html">
    
  
  <!-- Icon -->
  <link rel="apple-touch-icon" sizes="57x57" href="/vtk-js/icon/apple-touch-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/vtk-js/icon/apple-touch-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/vtk-js/icon/apple-touch-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/vtk-js/icon/apple-touch-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/vtk-js/icon/apple-touch-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/vtk-js/icon/apple-touch-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/vtk-js/icon/apple-touch-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/vtk-js/icon/apple-touch-icon-152x152.png">
  <link rel="icon" type="image/png" href="/vtk-js/icon/favicon-196x196.png" sizes="196x196">
  <link rel="icon" type="image/png" href="/vtk-js/icon/favicon-160x160.png" sizes="160x160">
  <link rel="icon" type="image/png" href="/vtk-js/icon/favicon-96x96.png" sizes="96x96">
  <link rel="icon" type="image/png" href="/vtk-js/icon/favicon-16x16.png" sizes="16x16">
  <link rel="icon" type="image/png" href="/vtk-js/icon/favicon-32x32.png" sizes="32x32">
  <meta name="msapplication-TileColor" content="#2f83cd">
  <meta name="msapplication-TileImage" content="/vtk-js/icon/mstile-144x144.png">
  <!-- CSS -->
  <!-- build:css build/css/navy.css -->
  
<link rel="stylesheet" href="/vtk-js/css/navy.css">

  <!-- endbuild -->
  <link href="https://fonts.googleapis.com/css?family=Lato:300,400,700" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.css">
  <!-- RSS -->
  <link rel="alternate" href="/vtk-js/atom.xml" title="vtk.js" type="application/atom+xml">
  <!-- Open Graph -->
  <meta name="description" content="IntroductionvtkContourTriangulator MethodsextendMethod use to decorate a given object (publicAPI+model) with vtkContourTriangulator characteristics.    Argument Type Required Description    publicAPI">
<meta property="og:type" content="website">
<meta property="og:title" content="ContourTriangulator">
<meta property="og:url" content="https://kitware.github.io/vtk-js/api/Filters_General_ContourTriangulator.html">
<meta property="og:site_name" content="vtk.js">
<meta property="og:description" content="IntroductionvtkContourTriangulator MethodsextendMethod use to decorate a given object (publicAPI+model) with vtkContourTriangulator characteristics.    Argument Type Required Description    publicAPI">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2024-02-28T16:05:51.965Z">
<meta property="article:modified_time" content="2024-02-28T16:05:51.965Z">
<meta property="article:author" content="Kitware Inc.">
<meta name="twitter:card" content="summary">
  <!-- Google Analytics -->
  
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-90338862-1', 'auto');
  ga('send', 'pageview');
</script>


<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-5XH2Z0Y9LQ"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-5XH2Z0Y9LQ');
</script>


<meta name="generator" content="Hexo 5.4.2"></head>

<body>
  <div id="container">
    <header id="header" class="wrapper">
  <div id="header-inner" class="inner">
    <h1 id="logo-wrap">
      <a href="/vtk-js/" id="logo">vtk.js</a>
    </h1>
    <nav id="main-nav">
      <a href="/vtk-js/docs/" class="main-nav-link">Docs</a><a href="/vtk-js/api/" class="main-nav-link">API</a><a href="/vtk-js/examples/" class="main-nav-link">Examples</a><a href="https://kitware.github.io/vtk-js-datasets/" class="main-nav-link">Sample data</a>
      <a target="_blank" rel="noopener" href="https://github.com/kitware/vtk-js" class="main-nav-link"><i class="fa fa-github-alt"></i></a>
      <div id="search-input-wrap">
        <div id="search-input-icon">
          <i class="fa fa-search"></i>
        </div>
        <input type="search" id="search-input" placeholder="Search...">
      </div>
    </nav>
    <a id="mobile-nav-toggle">
      <span class="mobile-nav-toggle-bar"></span>
      <span class="mobile-nav-toggle-bar"></span>
      <span class="mobile-nav-toggle-bar"></span>
    </a>
  </div>
</header>

    <div id="content-wrap">
  <div id="content" class="wrapper">
    <div id="content-inner">
      <article class="article-container" itemscope itemtype="http://schema.org/Article">
        <div class="article-inner">
          <div class="article">
            <div class="inner">
              <header class="article-header">
                <h1 class="article-title" itemprop="name">ContourTriangulator</h1>
              </header>
              <div class="article-content" itemprop="articleBody">
                <h2 id="Introduction" class="article-heading"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction<a class="article-anchor" href="#Introduction" aria-hidden="true"></a></h2><p>vtkContourTriangulator</p>
<h2 id="Methods" class="article-heading"><a href="#Methods" class="headerlink" title="Methods"></a>Methods<a class="article-anchor" href="#Methods" aria-hidden="true"></a></h2><h3 id="extend" class="article-heading"><a href="#extend" class="headerlink" title="extend"></a>extend<a class="article-anchor" href="#extend" aria-hidden="true"></a></h3><p>Method use to decorate a given object (publicAPI+model) with vtkContourTriangulator characteristics.</p>
<table>
<thead>
<tr>
<th>Argument</th>
<th>Type</th>
<th>Required</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>publicAPI</code></td>
<td></td>
<td>Yes</td>
<td>object on which methods will be bounds (public)</td>
</tr>
<tr>
<td><code>model</code></td>
<td></td>
<td>Yes</td>
<td>object on which data structure will be bounds (protected)</td>
</tr>
<tr>
<td><code>initialValues</code></td>
<td>IContourTriangulatorInitialValues</td>
<td>No</td>
<td>(default: {})</td>
</tr>
</tbody></table>
<h3 id="getTriangulatePolys" class="article-heading"><a href="#getTriangulatePolys" class="headerlink" title="getTriangulatePolys"></a>getTriangulatePolys<a class="article-anchor" href="#getTriangulatePolys" aria-hidden="true"></a></h3><p>Returns the behavior of the filter regarding polys.</p>
<h3 id="newInstance" class="article-heading"><a href="#newInstance" class="headerlink" title="newInstance"></a>newInstance<a class="article-anchor" href="#newInstance" aria-hidden="true"></a></h3><p>Method use to create a new instance of vtkContourTriangulator</p>
<table>
<thead>
<tr>
<th>Argument</th>
<th>Type</th>
<th>Required</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>initialValues</code></td>
<td>IContourTriangulatorInitialValues</td>
<td>No</td>
<td>for pre-setting some of its content</td>
</tr>
</tbody></table>
<h3 id="requestData" class="article-heading"><a href="#requestData" class="headerlink" title="requestData"></a>requestData<a class="article-anchor" href="#requestData" aria-hidden="true"></a></h3><table>
<thead>
<tr>
<th>Argument</th>
<th>Type</th>
<th>Required</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>inData</code></td>
<td>any</td>
<td>Yes</td>
<td></td>
</tr>
<tr>
<td><code>outData</code></td>
<td>any</td>
<td>Yes</td>
<td></td>
</tr>
</tbody></table>
<h3 id="setTriangulatePolys" class="article-heading"><a href="#setTriangulatePolys" class="headerlink" title="setTriangulatePolys"></a>setTriangulatePolys<a class="article-anchor" href="#setTriangulatePolys" aria-hidden="true"></a></h3><p>Sets the behavior of the filter regarding polys.</p>
<table>
<thead>
<tr>
<th>Argument</th>
<th>Type</th>
<th>Required</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>triangulate</code></td>
<td>boolean</td>
<td>Yes</td>
<td>whether the filter should triangulate polys or leave them untouched. True by default</td>
</tr>
</tbody></table>
<h3 id="triangulateContours" class="article-heading"><a href="#triangulateContours" class="headerlink" title="triangulateContours"></a>triangulateContours<a class="article-anchor" href="#triangulateContours" aria-hidden="true"></a></h3><p>This is a complex subroutine that takes a collection of lines that<br>were formed by cutting a polydata with a plane, and generates<br>a face that has those lines as its edges.  The lines must form one<br>or more closed contours, but they need not be sorted.</p>
<p>Only “numLine” lines starting from “firstLine” are used to create new<br>polygons, and the new polygons are appended to “polys”. The normal of<br>the cut plane must be provided so that polys will be correctly oriented.</p>
<p>Given some closed contour lines, create a triangle mesh that fills<br>those lines. The input lines do not have to be in tail-to-tip order.<br>Only numLines starting from firstLine will be used. Note that holes<br>can be indicated by contour loops whose normals are in the opposite<br>direction to the provided normal.</p>
<table>
<thead>
<tr>
<th>Argument</th>
<th>Type</th>
<th>Required</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>polyData</code></td>
<td>vtkPolyData</td>
<td>Yes</td>
<td></td>
</tr>
<tr>
<td><code>firstLine</code></td>
<td>Number</td>
<td>Yes</td>
<td></td>
</tr>
<tr>
<td><code>numLines</code></td>
<td>Number</td>
<td>Yes</td>
<td></td>
</tr>
<tr>
<td><code>polys</code></td>
<td>vtkCellArray</td>
<td>Yes</td>
<td></td>
</tr>
<tr>
<td><code>normal</code></td>
<td>Nullable.<vector3></vector3></td>
<td>Yes</td>
<td>If null, the function will compute the normal of the polys.</td>
</tr>
<tr>
<td><code>triangulatePolys</code></td>
<td>Boolean</td>
<td>No</td>
<td>(default: true) If set to true the resulting polygons will be triangulated, otherwise the polygons</td>
</tr>
<tr>
<td>themselves will be added to the output.</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>diagnoseOnTriangulationError</code></td>
<td>Boolean</td>
<td>No</td>
<td>(default: false) If this option is set to true and there was a triangulation error</td>
</tr>
<tr>
<td>this will add the polys as outlines to the output.</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h4 id="Returns" class="article-heading"><a href="#Returns" class="headerlink" title="Returns"></a>Returns<a class="article-anchor" href="#Returns" aria-hidden="true"></a></h4><table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>Boolean</td>
<td>Returns true if triangulation was successful, false otherwise.</td>
</tr>
</tbody></table>
<h3 id="triangulatePolygon" class="article-heading"><a href="#triangulatePolygon" class="headerlink" title="triangulatePolygon"></a>triangulatePolygon<a class="article-anchor" href="#triangulatePolygon" aria-hidden="true"></a></h3><p>A robust method for triangulating a polygon. It cleans up the polygon<br>and then applies the ear-cut triangulation. A zero return value<br>indicates that triangulation failed.</p>
<table>
<thead>
<tr>
<th>Argument</th>
<th>Type</th>
<th>Required</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>polygon</code></td>
<td>Array.<number> or TypedArray</number></td>
<td>Yes</td>
<td>Array of point indices defining the polygon</td>
</tr>
<tr>
<td><code>points</code></td>
<td>vtkPoints</td>
<td>Yes</td>
<td>The point coordinates of the polygon</td>
</tr>
<tr>
<td><code>triangles</code></td>
<td>vtkCellArray</td>
<td>Yes</td>
<td>The cell array that is going to be filled with the triangulation</td>
</tr>
</tbody></table>
<h4 id="Returns-1" class="article-heading"><a href="#Returns-1" class="headerlink" title="Returns"></a>Returns<a class="article-anchor" href="#Returns-1" aria-hidden="true"></a></h4><table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>Boolean</td>
<td>Returns true if triangulation was successful, false otherwise.</td>
</tr>
</tbody></table>
<h1 id="Source" class="article-heading"><a href="#Source" class="headerlink" title="Source"></a>Source<a class="article-anchor" href="#Source" aria-hidden="true"></a></h1><figure class="highlight js"><figcaption><span>Constants.js</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="variable constant_">CCS_POLYGON_TOLERANCE</span> = <span class="number">1e-5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123; <span class="variable constant_">CCS_POLYGON_TOLERANCE</span> &#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><figcaption><span>helper.js</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> macro <span class="keyword">from</span> <span class="string">&#x27;vtk.js/Sources/macros&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> vtkPoints <span class="keyword">from</span> <span class="string">&#x27;vtk.js/Sources/Common/Core/Points&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> vtkMath <span class="keyword">from</span> <span class="string">&#x27;vtk.js/Sources/Common/Core/Math&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> vtkLine <span class="keyword">from</span> <span class="string">&#x27;vtk.js/Sources/Common/DataModel/Line&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> vtkPolygon <span class="keyword">from</span> <span class="string">&#x27;vtk.js/Sources/Common/DataModel/Polygon&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> vtkIncrementalOctreePointLocator <span class="keyword">from</span> <span class="string">&#x27;vtk.js/Sources/Common/DataModel/IncrementalOctreePointLocator&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">VtkDataTypes</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;vtk.js/Sources/Common/Core/DataArray/Constants&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="variable constant_">CCS_POLYGON_TOLERANCE</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;./Constants&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">PolygonWithPointIntersectionState</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;../../../Common/DataModel/Polygon/Constants&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; vtkErrorMacro &#125; = macro;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Reverse the elements between the indices firstIdx and lastIdx of the given array arr.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Array|TypedArray</span>&#125; <span class="variable">arr</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Number</span>&#125; <span class="variable">firstIdx</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Number</span>&#125; <span class="variable">lastIdx</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">reverseElements</span>(<span class="params"></span></span><br><span class="line"><span class="params">  arr,</span></span><br><span class="line"><span class="params">  firstIdx = <span class="literal">undefined</span>,</span></span><br><span class="line"><span class="params">  lastIdx = <span class="literal">undefined</span></span></span><br><span class="line"><span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> first = firstIdx ?? <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">const</span> last = lastIdx ?? arr.<span class="property">length</span> - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">const</span> mid = first + <span class="title class_">Math</span>.<span class="title function_">floor</span>((last - first) / <span class="number">2</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = first; i &lt;= mid; ++i) &#123;</span><br><span class="line">    [arr[i], arr[last - (i - first)]] = [arr[last - (i - first)], arr[i]];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ---------------------------------------------------</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Compute the quality of a triangle.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Vector3</span>&#125; <span class="variable">p0</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Vector3</span>&#125; <span class="variable">p1</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Vector3</span>&#125; <span class="variable">p2</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Vector3</span>&#125; <span class="variable">normal</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns</span> &#123;<span class="type">Number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">vtkCCSTriangleQuality</span>(<span class="params">p0, p1, p2, normal</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> u = [];</span><br><span class="line">  <span class="keyword">const</span> v = [];</span><br><span class="line">  <span class="keyword">const</span> w = [];</span><br><span class="line"></span><br><span class="line">  vtkMath.<span class="title function_">subtract</span>(p1, p0, u);</span><br><span class="line">  vtkMath.<span class="title function_">subtract</span>(p2, p1, v);</span><br><span class="line">  vtkMath.<span class="title function_">subtract</span>(p0, p2, w);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> area2 =</span><br><span class="line">    (u[<span class="number">1</span>] * v[<span class="number">2</span>] - u[<span class="number">2</span>] * v[<span class="number">1</span>]) * normal[<span class="number">0</span>] +</span><br><span class="line">    (u[<span class="number">2</span>] * v[<span class="number">0</span>] - u[<span class="number">0</span>] * v[<span class="number">2</span>]) * normal[<span class="number">1</span>] +</span><br><span class="line">    (u[<span class="number">0</span>] * v[<span class="number">1</span>] - u[<span class="number">1</span>] * v[<span class="number">0</span>]) * normal[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> perim =</span><br><span class="line">    <span class="title class_">Math</span>.<span class="title function_">sqrt</span>(u[<span class="number">0</span>] * u[<span class="number">0</span>] + u[<span class="number">1</span>] * u[<span class="number">1</span>] + u[<span class="number">2</span>] * u[<span class="number">2</span>]) +</span><br><span class="line">    <span class="title class_">Math</span>.<span class="title function_">sqrt</span>(v[<span class="number">0</span>] * v[<span class="number">0</span>] + v[<span class="number">1</span>] * v[<span class="number">1</span>] + v[<span class="number">2</span>] * v[<span class="number">2</span>]) +</span><br><span class="line">    <span class="title class_">Math</span>.<span class="title function_">sqrt</span>(w[<span class="number">0</span>] * w[<span class="number">0</span>] + w[<span class="number">1</span>] * w[<span class="number">1</span>] + w[<span class="number">2</span>] * w[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">  perim *= perim; <span class="comment">// square the perimeter</span></span><br><span class="line">  perim = perim !== <span class="number">0</span> ? perim : <span class="number">1.0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// use a normalization factor so equilateral quality is 1.0</span></span><br><span class="line">  <span class="keyword">return</span> (area2 / perim) * <span class="number">10.392304845413264</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ---------------------------------------------------</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Insert a triangle, and subdivide that triangle if one of</span></span><br><span class="line"><span class="comment"> * its edges originally had more than two points before</span></span><br><span class="line"><span class="comment"> * vtkCCSFindTrueEdges was called. Is called by vtkCCSTriangulate.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">vtkCellArray</span>&#125; <span class="variable">polys</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Array|TypedArray</span>&#125; <span class="variable">poly</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Vector3</span>&#125; <span class="variable">trids</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Array|TypedArray</span>&#125; <span class="variable">polyEdges</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Array|TypedArray</span>&#125; <span class="variable">originalEdges</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">vtkCCSInsertTriangle</span>(<span class="params"></span></span><br><span class="line"><span class="params">  polys,</span></span><br><span class="line"><span class="params">  poly,</span></span><br><span class="line"><span class="params">  trids,</span></span><br><span class="line"><span class="params">  polyEdges,</span></span><br><span class="line"><span class="params">  originalEdges</span></span><br><span class="line"><span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> nextVert = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// To store how many of originalEdges match</span></span><br><span class="line">  <span class="keyword">let</span> edgeCount = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">const</span> edgeLocs = [-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Check for original edge matches</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> vert = <span class="number">0</span>; vert &lt; <span class="number">3</span>; vert++) &#123;</span><br><span class="line">    <span class="keyword">const</span> currId = trids[vert];</span><br><span class="line">    <span class="keyword">const</span> edgeLoc = polyEdges[currId];</span><br><span class="line">    <span class="keyword">if</span> (edgeLoc &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">let</span> nextId = currId + <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span> (nextId === poly.<span class="property">length</span>) &#123;</span><br><span class="line">        nextId = <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Is the triangle edge a polygon edge?</span></span><br><span class="line">      <span class="keyword">if</span> (nextId === trids[nextVert[vert]]) &#123;</span><br><span class="line">        edgeLocs[vert] = edgeLoc;</span><br><span class="line">        edgeCount++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (edgeCount === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// No special edge handling, so just do one triangle</span></span><br><span class="line">    polys.<span class="title function_">insertNextCell</span>([poly[trids[<span class="number">0</span>]], poly[trids[<span class="number">1</span>]], poly[trids[<span class="number">2</span>]]]);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// Make triangle fans for edges with extra points</span></span><br><span class="line">    <span class="keyword">const</span> edgePts = [</span><br><span class="line">      [poly[trids[<span class="number">0</span>]], poly[trids[<span class="number">1</span>]]],</span><br><span class="line">      [poly[trids[<span class="number">1</span>]], poly[trids[<span class="number">2</span>]]],</span><br><span class="line">      [poly[trids[<span class="number">2</span>]], poly[trids[<span class="number">0</span>]]],</span><br><span class="line">    ];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Find out which edge has the most extra points</span></span><br><span class="line">    <span class="keyword">let</span> maxPoints = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> currSide = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (edgeLocs[i] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> edgeLoc = edgeLocs[i];</span><br><span class="line">        <span class="keyword">const</span> npts = originalEdges[edgeLoc];</span><br><span class="line">        <span class="keyword">const</span> pts = originalEdges.<span class="title function_">slice</span>(edgeLoc + <span class="number">1</span>, edgeLoc + <span class="number">1</span> + npts);</span><br><span class="line">        <span class="keyword">if</span> (!(edgePts[i][<span class="number">0</span>] === pts[<span class="number">0</span>] || edgePts[i][<span class="number">1</span>] === pts[npts - <span class="number">1</span>])) &#123;</span><br><span class="line">          <span class="title function_">vtkErrorMacro</span>(<span class="string">&#x27;assertion error in vtkCCSInsertTriangle&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (npts &gt; maxPoints) &#123;</span><br><span class="line">          maxPoints = npts;</span><br><span class="line">          currSide = i;</span><br><span class="line">        &#125;</span><br><span class="line">        edgePts[i] = pts;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Find the edges before/after the edge with most points</span></span><br><span class="line">    <span class="keyword">const</span> prevSide = (currSide + <span class="number">2</span>) % <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">const</span> nextSide = (currSide + <span class="number">1</span>) % <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If other edges have only 2 points, nothing to do with them</span></span><br><span class="line">    <span class="keyword">const</span> prevNeeded = edgePts[prevSide].<span class="property">length</span> &gt; <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">const</span> nextNeeded = edgePts[nextSide].<span class="property">length</span> &gt; <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The tail is the common point in the triangle fan</span></span><br><span class="line">    <span class="keyword">const</span> tailPtIds = [];</span><br><span class="line">    tailPtIds[prevSide] = edgePts[currSide][<span class="number">1</span>];</span><br><span class="line">    tailPtIds[currSide] = edgePts[prevSide][<span class="number">0</span>];</span><br><span class="line">    tailPtIds[nextSide] = edgePts[currSide][edgePts[currSide].<span class="property">length</span> - <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Go through the sides and make the fans</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> side = <span class="number">0</span>; side &lt; <span class="number">3</span>; side++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (</span><br><span class="line">        (side !== prevSide || prevNeeded) &amp;&amp;</span><br><span class="line">        (side !== nextSide || nextNeeded)</span><br><span class="line">      ) &#123;</span><br><span class="line">        <span class="keyword">let</span> m = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">let</span> n = edgePts[side].<span class="property">length</span> - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (side === currSide) &#123;</span><br><span class="line">          m += prevNeeded;</span><br><span class="line">          n -= nextNeeded;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> k = m; k &lt; n; k++) &#123;</span><br><span class="line">          polys.<span class="title function_">insertNextCell</span>([</span><br><span class="line">            edgePts[side][k],</span><br><span class="line">            edgePts[side][k + <span class="number">1</span>],</span><br><span class="line">            tailPtIds[side],</span><br><span class="line">          ]);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ---------------------------------------------------</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Triangulate a polygon that has been simplified by FindTrueEdges.</span></span><br><span class="line"><span class="comment"> * This will re-insert the original edges.  The output triangles are</span></span><br><span class="line"><span class="comment"> * appended to &quot;polys&quot; and, for each stored triangle, &quot;color&quot; will</span></span><br><span class="line"><span class="comment"> * be added to &quot;scalars&quot;.  The final two arguments (polygon and</span></span><br><span class="line"><span class="comment"> * triangles) are only for temporary storage.</span></span><br><span class="line"><span class="comment"> * The return value is true if triangulation was successful.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Array</span>&#125; <span class="variable">poly</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">vtkPoints</span>&#125; <span class="variable">points</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Array</span>&#125; <span class="variable">polyEdges</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Array</span>&#125; <span class="variable">originalEdges</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">vtkCellArray</span>&#125; <span class="variable">polys</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Vector3</span>&#125; <span class="variable">normal</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns</span> &#123;<span class="type">boolean</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">vtkCCSTriangulate</span>(<span class="params"></span></span><br><span class="line"><span class="params">  poly,</span></span><br><span class="line"><span class="params">  points,</span></span><br><span class="line"><span class="params">  polyEdges,</span></span><br><span class="line"><span class="params">  originalEdges,</span></span><br><span class="line"><span class="params">  polys,</span></span><br><span class="line"><span class="params">  normal</span></span><br><span class="line"><span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> n = poly.<span class="property">length</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If the poly is a line, then skip it</span></span><br><span class="line">  <span class="keyword">if</span> (n &lt; <span class="number">3</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If the poly is a triangle, then pass it</span></span><br><span class="line">  <span class="keyword">if</span> (n === <span class="number">3</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> trids = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">    <span class="title function_">vtkCCSInsertTriangle</span>(polys, poly, trids, polyEdges, originalEdges);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If the poly has 4 or more points, triangulate it</span></span><br><span class="line">  <span class="keyword">let</span> triangulationFailure = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">let</span> ppoint = [];</span><br><span class="line">  <span class="keyword">let</span> point = [];</span><br><span class="line">  <span class="keyword">let</span> npoint = [];</span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> j = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> k = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> verts = [];</span><br><span class="line">  verts.<span class="property">length</span> = n;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    verts[i] = [i, <span class="number">0</span>];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// compute the triangle quality for each vert</span></span><br><span class="line">  k = n - <span class="number">2</span>;</span><br><span class="line">  points.<span class="title function_">getPoint</span>(poly[verts[k][<span class="number">0</span>]], point);</span><br><span class="line">  i = n - <span class="number">1</span>;</span><br><span class="line">  points.<span class="title function_">getPoint</span>(poly[verts[i][<span class="number">0</span>]], npoint);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> concave = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> maxq = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> maxi = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">    [ppoint, point, npoint] = [point, npoint, ppoint];</span><br><span class="line">    points.<span class="title function_">getPoint</span>(poly[verts[j][<span class="number">0</span>]], npoint);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> q = <span class="title function_">vtkCCSTriangleQuality</span>(ppoint, point, npoint, normal);</span><br><span class="line">    <span class="keyword">if</span> (q &gt; maxq) &#123;</span><br><span class="line">      maxi = i;</span><br><span class="line">      maxq = q;</span><br><span class="line">    &#125;</span><br><span class="line">    concave += q &lt; <span class="number">0</span>;</span><br><span class="line">    verts[i][<span class="number">1</span>] = q;</span><br><span class="line">    i = j;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> foundEar;</span><br><span class="line">  <span class="comment">// perform the ear-cut triangulation</span></span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    <span class="comment">// if no potential ears were found, then fail</span></span><br><span class="line">    <span class="keyword">if</span> (maxq &lt;= <span class="title class_">Number</span>.<span class="property">MIN_VALUE</span>) &#123;</span><br><span class="line">      triangulationFailure = <span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    i = maxi;</span><br><span class="line">    j = i + <span class="number">1</span> !== n ? i + <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    k = i !== <span class="number">0</span> ? i - <span class="number">1</span> : n - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (verts[i][<span class="number">1</span>] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      foundEar = <span class="literal">true</span>;</span><br><span class="line">      points.<span class="title function_">getPoint</span>(poly[verts[j][<span class="number">0</span>]], npoint);</span><br><span class="line">      points.<span class="title function_">getPoint</span>(poly[verts[k][<span class="number">0</span>]], ppoint);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// only do ear check if there are concave vertices</span></span><br><span class="line">      <span class="keyword">if</span> (concave) &#123;</span><br><span class="line">        <span class="comment">// get the normal of the split plane</span></span><br><span class="line">        <span class="keyword">const</span> v = [];</span><br><span class="line">        <span class="keyword">const</span> u = [];</span><br><span class="line"></span><br><span class="line">        vtkMath.<span class="title function_">subtract</span>(npoint, ppoint, v);</span><br><span class="line">        vtkMath.<span class="title function_">cross</span>(v, normal, u);</span><br><span class="line">        <span class="keyword">const</span> d = vtkMath.<span class="title function_">dot</span>(ppoint, u);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> jj = j + <span class="number">1</span> !== n ? j + <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">let</span> x = [];</span><br><span class="line">        points.<span class="title function_">getPoint</span>(poly[verts[jj][<span class="number">0</span>]], x);</span><br><span class="line">        <span class="keyword">let</span> side = vtkMath.<span class="title function_">dot</span>(x, u) &lt; d;</span><br><span class="line">        <span class="keyword">let</span> foundNegative = side;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// check for crossings of the split plane</span></span><br><span class="line">        jj = jj + <span class="number">1</span> !== n ? jj + <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">let</span> y = [];</span><br><span class="line">        <span class="keyword">const</span> s = [];</span><br><span class="line">        <span class="keyword">const</span> t = [];</span><br><span class="line">        <span class="keyword">for</span> (; foundEar &amp;&amp; jj !== k; jj = jj + <span class="number">1</span> !== n ? jj + <span class="number">1</span> : <span class="number">0</span>) &#123;</span><br><span class="line">          [x, y] = [y, x];</span><br><span class="line">          points.<span class="title function_">getPoint</span>(poly[verts[jj][<span class="number">0</span>]], x);</span><br><span class="line">          <span class="keyword">const</span> sside = vtkMath.<span class="title function_">dot</span>(x, u) &lt; d;</span><br><span class="line">          <span class="comment">// XOR</span></span><br><span class="line">          <span class="keyword">if</span> (side ? !sside : sside) &#123;</span><br><span class="line">            side = !side;</span><br><span class="line">            foundNegative = <span class="literal">true</span>;</span><br><span class="line">            foundEar =</span><br><span class="line">              vtkLine.<span class="title function_">intersection</span>(ppoint, npoint, x, y, s, t) ===</span><br><span class="line">              vtkLine.<span class="property">IntersectionState</span>.<span class="property">NO_INTERSECTION</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        foundEar &amp;&amp;= foundNegative;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!foundEar) &#123;</span><br><span class="line">        <span class="comment">// don&#x27;t try again until it is split</span></span><br><span class="line">        verts[i][<span class="number">1</span>] = <span class="title class_">Number</span>.<span class="property">MIN_VALUE</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// create a triangle from vertex and neighbors</span></span><br><span class="line">        <span class="keyword">const</span> trids = [verts[i][<span class="number">0</span>], verts[j][<span class="number">0</span>], verts[k][<span class="number">0</span>]];</span><br><span class="line">        <span class="title function_">vtkCCSInsertTriangle</span>(polys, poly, trids, polyEdges, originalEdges);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// remove the vertex i</span></span><br><span class="line">        verts.<span class="title function_">splice</span>(i, <span class="number">1</span>);</span><br><span class="line">        k -= i === <span class="number">0</span>;</span><br><span class="line">        j -= j !== <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// break if this was final triangle</span></span><br><span class="line">        <span class="keyword">if</span> (--n &lt; <span class="number">3</span>) &#123;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// re-compute quality of previous point</span></span><br><span class="line">        <span class="keyword">const</span> kk = k !== <span class="number">0</span> ? k - <span class="number">1</span> : n - <span class="number">1</span>;</span><br><span class="line">        points.<span class="title function_">getPoint</span>(poly[verts[kk][<span class="number">0</span>]], point);</span><br><span class="line">        <span class="keyword">const</span> kq = <span class="title function_">vtkCCSTriangleQuality</span>(point, ppoint, npoint, normal);</span><br><span class="line">        concave -= verts[k][<span class="number">1</span>] &lt; <span class="number">0</span> &amp;&amp; kq &gt;= <span class="number">0</span>;</span><br><span class="line">        verts[k][<span class="number">1</span>] = kq;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// re-compute quality of next point</span></span><br><span class="line">        <span class="keyword">const</span> jj = j + <span class="number">1</span> !== n ? j + <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        points.<span class="title function_">getPoint</span>(poly[verts[jj][<span class="number">0</span>]], point);</span><br><span class="line">        <span class="keyword">const</span> jq = <span class="title function_">vtkCCSTriangleQuality</span>(ppoint, npoint, point, normal);</span><br><span class="line">        concave -= verts[j][<span class="number">1</span>] &lt; <span class="number">0</span> &amp;&amp; jq &gt;= <span class="number">0</span>;</span><br><span class="line">        verts[j][<span class="number">1</span>] = jq;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// find the highest-quality ear candidate</span></span><br><span class="line">    maxi = <span class="number">0</span>;</span><br><span class="line">    maxq = verts[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">      <span class="keyword">const</span> q = verts[i][<span class="number">1</span>];</span><br><span class="line">      <span class="keyword">if</span> (q &gt; maxq) &#123;</span><br><span class="line">        maxi = i;</span><br><span class="line">        maxq = q;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> !triangulationFailure;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ---------------------------------------------------</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Create polygons from line segments.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">vtkPolyData</span>&#125; <span class="variable">polyData</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Number</span>&#125; <span class="variable">firstLine</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Number</span>&#125; <span class="variable">endLine</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Boolean</span>&#125; <span class="variable">oriented</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Array</span>&#125; <span class="variable">newPolys</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Array</span>&#125; <span class="variable">incompletePolys</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">vtkCCSMakePolysFromLines</span>(<span class="params"></span></span><br><span class="line"><span class="params">  polyData,</span></span><br><span class="line"><span class="params">  firstLine,</span></span><br><span class="line"><span class="params">  endLine,</span></span><br><span class="line"><span class="params">  oriented,</span></span><br><span class="line"><span class="params">  newPolys,</span></span><br><span class="line"><span class="params">  incompletePolys</span></span><br><span class="line"><span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> npts = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> pts = [];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Bitfield for marking lines as used</span></span><br><span class="line">  <span class="keyword">const</span> usedLines = <span class="keyword">new</span> <span class="title class_">Uint8Array</span>(endLine - firstLine); <span class="comment">// defaults to 0</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Require cell links to get lines from pointIds</span></span><br><span class="line">  polyData.<span class="title function_">buildLinks</span>(polyData.<span class="title function_">getPoints</span>().<span class="title function_">getNumberOfPoints</span>());</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> numNewPolys = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> remainingLines = endLine - firstLine;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (remainingLines &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// Create a new poly</span></span><br><span class="line">    <span class="keyword">const</span> polyId = numNewPolys++;</span><br><span class="line">    <span class="keyword">const</span> poly = [];</span><br><span class="line">    newPolys.<span class="title function_">push</span>(poly);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> lineId = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> completePoly = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// start the poly</span></span><br><span class="line">    <span class="keyword">for</span> (lineId = firstLine; lineId &lt; endLine; lineId++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!usedLines[lineId - firstLine]) &#123;</span><br><span class="line">        pts = polyData.<span class="title function_">getCellPoints</span>(lineId).<span class="property">cellPointIds</span>;</span><br><span class="line">        npts = pts.<span class="property">length</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> n = npts;</span><br><span class="line">        <span class="keyword">if</span> (npts &gt; <span class="number">2</span> &amp;&amp; pts[<span class="number">0</span>] === pts[npts - <span class="number">1</span>]) &#123;</span><br><span class="line">          n = npts - <span class="number">1</span>;</span><br><span class="line">          completePoly = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        poly.<span class="property">length</span> = n;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">          poly[i] = pts[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    usedLines[lineId - firstLine] = <span class="number">1</span>;</span><br><span class="line">    remainingLines--;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> noLinesMatch = remainingLines === <span class="number">0</span> &amp;&amp; !completePoly;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!completePoly &amp;&amp; !noLinesMatch &amp;&amp; remainingLines &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// This is cleared if a match is found</span></span><br><span class="line">      noLinesMatch = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Number of points in the poly</span></span><br><span class="line">      <span class="keyword">const</span> npoly = poly.<span class="property">length</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">const</span> lineEndPts = [];</span><br><span class="line">      <span class="keyword">const</span> endPts = [poly[npoly - <span class="number">1</span>], poly[<span class="number">0</span>]];</span><br><span class="line"></span><br><span class="line">      <span class="comment">// For both open ends of the polygon</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> endIdx = <span class="number">0</span>; endIdx &lt; <span class="number">2</span>; endIdx++) &#123;</span><br><span class="line">        <span class="keyword">const</span> matches = [];</span><br><span class="line">        <span class="keyword">const</span> cells = polyData.<span class="title function_">getPointCells</span>(endPts[endIdx]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Go through all lines that contain this endpoint</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> icell = <span class="number">0</span>; icell &lt; cells.<span class="property">length</span>; icell++) &#123;</span><br><span class="line">          lineId = cells[icell];</span><br><span class="line">          <span class="keyword">if</span> (</span><br><span class="line">            lineId &gt;= firstLine &amp;&amp;</span><br><span class="line">            lineId &lt; endLine &amp;&amp;</span><br><span class="line">            !usedLines[lineId - firstLine]</span><br><span class="line">          ) &#123;</span><br><span class="line">            pts = polyData.<span class="title function_">getCellPoints</span>(lineId).<span class="property">cellPointIds</span>;</span><br><span class="line">            npts = pts.<span class="property">length</span>;</span><br><span class="line">            lineEndPts[<span class="number">0</span>] = pts[<span class="number">0</span>];</span><br><span class="line">            lineEndPts[<span class="number">1</span>] = pts[npts - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Check that poly end matches line end</span></span><br><span class="line">            <span class="keyword">if</span> (</span><br><span class="line">              endPts[endIdx] === lineEndPts[endIdx] ||</span><br><span class="line">              (!oriented &amp;&amp; endPts[endIdx] === lineEndPts[<span class="number">1</span> - endIdx])</span><br><span class="line">            ) &#123;</span><br><span class="line">              matches.<span class="title function_">push</span>(lineId);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (matches.<span class="property">length</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="comment">// Multiple matches mean we need to decide which path to take</span></span><br><span class="line">          <span class="keyword">if</span> (matches.<span class="property">length</span> &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// Remove double-backs</span></span><br><span class="line">            <span class="keyword">let</span> k = matches.<span class="property">length</span>;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">              lineId = matches[--k];</span><br><span class="line">              pts = polyData.<span class="title function_">getCellPoints</span>(lineId).<span class="property">cellPointIds</span>;</span><br><span class="line">              npts = pts.<span class="property">length</span>;</span><br><span class="line">              lineEndPts[<span class="number">0</span>] = pts[<span class="number">0</span>];</span><br><span class="line">              lineEndPts[<span class="number">1</span>] = pts[npts - <span class="number">1</span>];</span><br><span class="line">              <span class="comment">// check if line is reversed</span></span><br><span class="line">              <span class="keyword">const</span> r = endPts[endIdx] !== lineEndPts[endIdx];</span><br><span class="line"></span><br><span class="line">              <span class="keyword">if</span> (</span><br><span class="line">                (!r &amp;&amp;</span><br><span class="line">                  ((endIdx === <span class="number">0</span> &amp;&amp; poly[npoly - <span class="number">2</span>] === pts[<span class="number">1</span>]) ||</span><br><span class="line">                    (endIdx === <span class="number">1</span> &amp;&amp; poly[<span class="number">1</span>] === pts[npts - <span class="number">2</span>]))) ||</span><br><span class="line">                (r &amp;&amp;</span><br><span class="line">                  ((endIdx === <span class="number">0</span> &amp;&amp; poly[npoly - <span class="number">2</span>] === pts[npts - <span class="number">2</span>]) ||</span><br><span class="line">                    (endIdx === <span class="number">1</span> &amp;&amp; poly[<span class="number">1</span>] === pts[<span class="number">1</span>])))</span><br><span class="line">              ) &#123;</span><br><span class="line">                matches.<span class="title function_">splice</span>(k, <span class="number">1</span>);</span><br><span class="line">              &#125;</span><br><span class="line">            &#125; <span class="keyword">while</span> (k &gt; <span class="number">0</span> &amp;&amp; matches.<span class="property">length</span> &gt; <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// If there are multiple matches due to intersections,</span></span><br><span class="line">            <span class="comment">// they should be dealt with here.</span></span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          lineId = matches[<span class="number">0</span>];</span><br><span class="line">          pts = polyData.<span class="title function_">getCellPoints</span>(lineId).<span class="property">cellPointIds</span>;</span><br><span class="line">          npts = pts.<span class="property">length</span>;</span><br><span class="line">          lineEndPts[<span class="number">0</span>] = pts[<span class="number">0</span>];</span><br><span class="line">          lineEndPts[<span class="number">1</span>] = pts[npts - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">          <span class="comment">// Do both ends match?</span></span><br><span class="line">          <span class="keyword">if</span> (endPts[endIdx] === lineEndPts[endIdx]) &#123;</span><br><span class="line">            completePoly = endPts[<span class="number">1</span> - endIdx] === lineEndPts[<span class="number">1</span> - endIdx];</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            completePoly = endPts[<span class="number">1</span> - endIdx] === lineEndPts[endIdx];</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (endIdx === <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; npts - (completePoly ? <span class="number">1</span> : <span class="number">0</span>); i++) &#123;</span><br><span class="line">              poly.<span class="title function_">push</span>(pts[i]);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = completePoly ? <span class="number">1</span> : <span class="number">0</span>; i &lt; npts - <span class="number">1</span>; i++) &#123;</span><br><span class="line">              poly.<span class="title function_">unshift</span>(pts[i]);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (endPts[endIdx] !== lineEndPts[endIdx]) &#123;</span><br><span class="line">            <span class="comment">// reverse the ids in the added line</span></span><br><span class="line">            <span class="keyword">let</span> pit = poly.<span class="property">length</span>;</span><br><span class="line">            <span class="keyword">let</span> ptsIt = completePoly ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">let</span> ptsEnd = npts - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (endIdx === <span class="number">1</span>) &#123;</span><br><span class="line">              pit = npts - <span class="number">1</span> - (completePoly ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">              ptsIt = <span class="number">1</span>;</span><br><span class="line">              ptsEnd = npts - (completePoly ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (ptsIt !== ptsEnd) &#123;</span><br><span class="line">              poly[--pit] = poly[ptsIt++];</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          usedLines[lineId - firstLine] = <span class="number">1</span>;</span><br><span class="line">          remainingLines--;</span><br><span class="line">          noLinesMatch = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check for incomplete polygons</span></span><br><span class="line">    <span class="keyword">if</span> (noLinesMatch) &#123;</span><br><span class="line">      incompletePolys.<span class="title function_">push</span>(polyId);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ---------------------------------------------------</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Join polys that have loose ends, as indicated by incompletePolys.</span></span><br><span class="line"><span class="comment"> * Any polys created will have a normal opposite to the supplied normal,</span></span><br><span class="line"><span class="comment"> * and any new edges that are created will be on the hull of the point set.</span></span><br><span class="line"><span class="comment"> * Shorter edges will be preferred over long edges.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Array[]</span>&#125; <span class="variable">polys</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Array</span>&#125; <span class="variable">incompletePolys</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">vtkPoints</span>&#125; <span class="variable">points</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Vector3</span>&#125; <span class="variable">normal</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">vtkCCSJoinLooseEnds</span>(<span class="params">polys, incompletePolys, points, normal</span>) &#123;</span><br><span class="line">  <span class="comment">// Relative tolerance for checking whether an edge is on the hull</span></span><br><span class="line">  <span class="keyword">const</span> tol = <span class="variable constant_">CCS_POLYGON_TOLERANCE</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// A list of polys to remove when everything is done</span></span><br><span class="line">  <span class="keyword">const</span> removePolys = [];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> p1 = [];</span><br><span class="line">  <span class="keyword">const</span> p2 = [];</span><br><span class="line">  <span class="keyword">let</span> poly1;</span><br><span class="line">  <span class="keyword">let</span> poly2;</span><br><span class="line">  <span class="keyword">let</span> pt1;</span><br><span class="line">  <span class="keyword">let</span> pt2;</span><br><span class="line">  <span class="keyword">let</span> dMin;</span><br><span class="line">  <span class="keyword">let</span> iMin;</span><br><span class="line">  <span class="keyword">let</span> v;</span><br><span class="line">  <span class="keyword">let</span> d;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> n = incompletePolys.<span class="property">length</span>;</span><br><span class="line">  <span class="keyword">while</span> (n !== <span class="number">0</span>) &#123;</span><br><span class="line">    poly1 = polys[incompletePolys[n - <span class="number">1</span>]];</span><br><span class="line">    pt1 = poly1[poly1.<span class="property">length</span> - <span class="number">1</span>];</span><br><span class="line">    points.<span class="title function_">getPoint</span>(pt1, p1);</span><br><span class="line"></span><br><span class="line">    dMin = <span class="title class_">Number</span>.<span class="property">MAX_VALUE</span>;</span><br><span class="line">    iMin = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">      poly2 = polys[incompletePolys[i]];</span><br><span class="line">      pt2 = poly2[<span class="number">0</span>];</span><br><span class="line">      points.<span class="title function_">getPoint</span>(pt2, p2);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// The next few steps verify that edge [p1, p2] is on the hull</span></span><br><span class="line">      v = [p2[<span class="number">0</span>] - p1[<span class="number">0</span>], p2[<span class="number">1</span>] - p1[<span class="number">1</span>], p2[<span class="number">2</span>] - p1[<span class="number">2</span>]];</span><br><span class="line">      d = vtkMath.<span class="title function_">norm</span>(v);</span><br><span class="line">      <span class="keyword">if</span> (d !== <span class="number">0</span>) &#123;</span><br><span class="line">        v[<span class="number">0</span>] /= d;</span><br><span class="line">        v[<span class="number">1</span>] /= d;</span><br><span class="line">        v[<span class="number">2</span>] /= d;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Compute the midpoint of the edge</span></span><br><span class="line">      <span class="keyword">const</span> pm = [</span><br><span class="line">        <span class="number">0.5</span> * (p1[<span class="number">0</span>] + p2[<span class="number">0</span>]),</span><br><span class="line">        <span class="number">0.5</span> * (p1[<span class="number">1</span>] + p2[<span class="number">1</span>]),</span><br><span class="line">        <span class="number">0.5</span> * (p1[<span class="number">2</span>] + p2[<span class="number">2</span>]),</span><br><span class="line">      ];</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Create a plane equation</span></span><br><span class="line">      <span class="keyword">const</span> pc = [];</span><br><span class="line">      vtkMath.<span class="title function_">cross</span>(normal, v, pc);</span><br><span class="line">      pc[<span class="number">3</span>] = -vtkMath.<span class="title function_">dot</span>(pc, pm);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Check that all points are inside the plane.  If they aren&#x27;t, then</span></span><br><span class="line">      <span class="comment">// the edge is not on the hull of the pointset.</span></span><br><span class="line">      <span class="keyword">let</span> badPoint = <span class="literal">false</span>;</span><br><span class="line">      <span class="keyword">const</span> m = polys.<span class="property">length</span>;</span><br><span class="line">      <span class="keyword">const</span> p = [];</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; m &amp;&amp; !badPoint; j++) &#123;</span><br><span class="line">        <span class="keyword">const</span> poly = polys[j];</span><br><span class="line">        <span class="keyword">const</span> npts = poly.<span class="property">length</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> k = <span class="number">0</span>; k &lt; npts; k++) &#123;</span><br><span class="line">          <span class="keyword">const</span> ptId = poly[k];</span><br><span class="line">          <span class="keyword">if</span> (ptId !== pt1 &amp;&amp; ptId !== pt2) &#123;</span><br><span class="line">            points.<span class="title function_">getPoint</span>(ptId, p);</span><br><span class="line">            <span class="keyword">const</span> val = p[<span class="number">0</span>] * pc[<span class="number">0</span>] + p[<span class="number">1</span>] * pc[<span class="number">1</span>] + p[<span class="number">2</span>] * pc[<span class="number">2</span>] + pc[<span class="number">3</span>];</span><br><span class="line">            <span class="keyword">const</span> r2 = vtkMath.<span class="title function_">distance2BetweenPoints</span>(p, pm);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Check distance from plane against the tolerance</span></span><br><span class="line">            <span class="keyword">if</span> (val &lt; <span class="number">0</span> &amp;&amp; val * val &gt; tol * tol * r2) &#123;</span><br><span class="line">              badPoint = <span class="literal">true</span>;</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If no bad points, then this edge is a candidate</span></span><br><span class="line">        <span class="keyword">if</span> (!badPoint &amp;&amp; d &lt; dMin) &#123;</span><br><span class="line">          dMin = d;</span><br><span class="line">          iMin = i;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If a match was found, append the polys</span></span><br><span class="line">    <span class="keyword">if</span> (dMin &lt; <span class="title class_">Number</span>.<span class="property">MAX_VALUE</span>) &#123;</span><br><span class="line">      <span class="comment">// Did the poly match with itself?</span></span><br><span class="line">      <span class="keyword">if</span> (iMin === n - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// Mark the poly as closed</span></span><br><span class="line">        incompletePolys.<span class="title function_">pop</span>();</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> id2 = incompletePolys[iMin];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Combine the polys</span></span><br><span class="line">        <span class="comment">// for (let i = 1; i &lt; polys[id2].length; i++) &#123;</span></span><br><span class="line">        <span class="comment">//   poly1.push(polys[id2][i]);</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        poly1.<span class="title function_">push</span>(...polys[id2]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Erase the second poly</span></span><br><span class="line">        removePolys.<span class="title function_">push</span>(id2);</span><br><span class="line">        incompletePolys.<span class="title function_">splice</span>(iMin, <span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// If no match, erase this poly from consideration</span></span><br><span class="line">      removePolys.<span class="title function_">push</span>(incompletePolys[n - <span class="number">1</span>]);</span><br><span class="line">      incompletePolys.<span class="title function_">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    n = incompletePolys.<span class="property">length</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Remove polys that couldn&#x27;t be completed</span></span><br><span class="line">  removePolys.<span class="title function_">sort</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b);</span><br><span class="line">  <span class="keyword">let</span> i = removePolys.<span class="property">length</span>;</span><br><span class="line">  <span class="keyword">while</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// Remove items in reverse order</span></span><br><span class="line">    polys.<span class="title function_">splice</span>(removePolys[--i], <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Clear the incompletePolys vector, it&#x27;s indices are no longer valid</span></span><br><span class="line">  incompletePolys.<span class="property">length</span> = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ---------------------------------------------------</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Given three vectors p.p1, p.p2, and p.p3, this routine</span></span><br><span class="line"><span class="comment"> * checks to see if progressing from p1 to p2 to p3 is a clockwise</span></span><br><span class="line"><span class="comment"> * or counterclockwise progression with respect to the normal.</span></span><br><span class="line"><span class="comment"> * The return value is -1 for clockwise, +1 for counterclockwise,</span></span><br><span class="line"><span class="comment"> * and 0 if any two of the vectors are coincident.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Vector3</span>&#125; <span class="variable">p</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Vector3</span>&#125; <span class="variable">p1</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Vector3</span>&#125; <span class="variable">p2</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Vector3</span>&#125; <span class="variable">p3</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Vector3</span>&#125; <span class="variable">normal</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns</span> &#123;<span class="type">Number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">vtkCCSVectorProgression</span>(<span class="params">p, p1, p2, p3, normal</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> v1 = [p1[<span class="number">0</span>] - p[<span class="number">0</span>], p1[<span class="number">1</span>] - p[<span class="number">1</span>], p1[<span class="number">2</span>] - p[<span class="number">2</span>]];</span><br><span class="line">  <span class="keyword">const</span> v2 = [p2[<span class="number">0</span>] - p[<span class="number">0</span>], p2[<span class="number">1</span>] - p[<span class="number">1</span>], p2[<span class="number">2</span>] - p[<span class="number">2</span>]];</span><br><span class="line">  <span class="keyword">const</span> v3 = [p3[<span class="number">0</span>] - p[<span class="number">0</span>], p3[<span class="number">1</span>] - p[<span class="number">1</span>], p3[<span class="number">2</span>] - p[<span class="number">2</span>]];</span><br><span class="line">  <span class="keyword">const</span> w1 = [];</span><br><span class="line">  <span class="keyword">const</span> w2 = [];</span><br><span class="line"></span><br><span class="line">  vtkMath.<span class="title function_">cross</span>(v2, v1, w1);</span><br><span class="line">  vtkMath.<span class="title function_">cross</span>(v2, v3, w2);</span><br><span class="line">  <span class="keyword">const</span> s1 = vtkMath.<span class="title function_">dot</span>(w1, normal);</span><br><span class="line">  <span class="keyword">const</span> s2 = vtkMath.<span class="title function_">dot</span>(w2, normal);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (s1 !== <span class="number">0</span> &amp;&amp; s2 !== <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> sb1 = s1 &lt; <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">const</span> sb2 = s2 &lt; <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// if sines have different signs</span></span><br><span class="line">    <span class="comment">// XOR</span></span><br><span class="line">    <span class="keyword">if</span> (sb1 ? !sb2 : sb2) &#123;</span><br><span class="line">      <span class="comment">// return -1 if s2 is -ve</span></span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span> - <span class="number">2</span> * sb2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> c1 = vtkMath.<span class="title function_">dot</span>(v2, v1);</span><br><span class="line">    <span class="keyword">const</span> l1 = vtkMath.<span class="title function_">norm</span>(v1);</span><br><span class="line">    <span class="keyword">const</span> c2 = vtkMath.<span class="title function_">dot</span>(v2, v3);</span><br><span class="line">    <span class="keyword">const</span> l2 = vtkMath.<span class="title function_">norm</span>(v3);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ck is the difference of the cosines, flipped in sign if sines are +ve</span></span><br><span class="line">    <span class="keyword">const</span> ck = (c2 * l2 - c1 * l1) * (<span class="number">1</span> - sb1 * <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ck !== <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// return the sign of ck</span></span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span> - <span class="number">2</span> * (ck &lt; <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ---------------------------------------------------</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Check for self-intersection. Split the figure-eights.</span></span><br><span class="line"><span class="comment"> * This assumes that all intersections occur at existing</span></span><br><span class="line"><span class="comment"> * vertices, i.e. no new vertices will be created. Returns</span></span><br><span class="line"><span class="comment"> * the number of splits made.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Array[]</span>&#125; <span class="variable">polys</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">vtkPoints</span>&#125; <span class="variable">points</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Array</span>&#125; <span class="variable">polyGroups</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Array</span>&#125; <span class="variable">polyEdges</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Vector3</span>&#125; <span class="variable">normal</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Boolean</span>&#125; <span class="variable">oriented</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">vtkCCSSplitAtPinchPoints</span>(<span class="params"></span></span><br><span class="line"><span class="params">  polys,</span></span><br><span class="line"><span class="params">  points,</span></span><br><span class="line"><span class="params">  polyGroups,</span></span><br><span class="line"><span class="params">  polyEdges,</span></span><br><span class="line"><span class="params">  normal,</span></span><br><span class="line"><span class="params">  oriented</span></span><br><span class="line"><span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> tryPoints = vtkPoints.<span class="title function_">newInstance</span>(&#123;</span><br><span class="line">    <span class="attr">dataType</span>: <span class="title class_">VtkDataTypes</span>.<span class="property">DOUBLE</span>,</span><br><span class="line">    <span class="attr">empty</span>: <span class="literal">true</span>,</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> locator = vtkIncrementalOctreePointLocator.<span class="title function_">newInstance</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> splitCount = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> poly;</span><br><span class="line">  <span class="keyword">let</span> n;</span><br><span class="line">  <span class="keyword">let</span> bounds;</span><br><span class="line">  <span class="keyword">let</span> tol;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; polys.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    poly = polys[i];</span><br><span class="line">    n = poly.<span class="property">length</span>;</span><br><span class="line"></span><br><span class="line">    bounds = [];</span><br><span class="line">    tol =</span><br><span class="line">      <span class="variable constant_">CCS_POLYGON_TOLERANCE</span> *</span><br><span class="line">      <span class="title class_">Math</span>.<span class="title function_">sqrt</span>(vtkPolygon.<span class="title function_">getBounds</span>(poly, points, bounds));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (tol === <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// eslint-disable-next-line no-continue</span></span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tryPoints.<span class="title function_">initialize</span>();</span><br><span class="line">    locator.<span class="title function_">setTolerance</span>(tol);</span><br><span class="line">    locator.<span class="title function_">initPointInsertion</span>(tryPoints, bounds);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> foundMatch = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">let</span> idx1 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> idx2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> unique = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">const</span> point = [];</span><br><span class="line">    <span class="keyword">const</span> p1 = [];</span><br><span class="line">    <span class="keyword">const</span> p2 = [];</span><br><span class="line">    <span class="keyword">const</span> p3 = [];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (idx2 = <span class="number">0</span>; idx2 &lt; n; idx2++) &#123;</span><br><span class="line">      points.<span class="title function_">getPoint</span>(poly[idx2], point);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">const</span> &#123; success, pointIdx &#125; = locator.<span class="title function_">insertUniquePoint</span>(point, <span class="number">0</span>);</span><br><span class="line">      <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">        <span class="comment">// Need vertIdx to match poly indices, so force point insertion</span></span><br><span class="line">        locator.<span class="title function_">insertNextPoint</span>(point);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Do the points have different pointIds?</span></span><br><span class="line">        idx1 = pointIdx;</span><br><span class="line">        unique = poly[idx2] !== poly[idx1];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (idx2 &gt; idx1 + <span class="number">2</span> - unique &amp;&amp; n + idx1 &gt; idx2 + <span class="number">2</span> - unique) &#123;</span><br><span class="line">          <span class="keyword">if</span> (oriented) &#123;</span><br><span class="line">            <span class="comment">// Make sure that splitting this poly won&#x27;t create a hole poly</span></span><br><span class="line">            <span class="keyword">let</span> prevIdx = n + idx1 - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">let</span> midIdx = idx1 + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">let</span> nextIdx = idx2 + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (prevIdx &gt;= n) &#123;</span><br><span class="line">              prevIdx -= n;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (midIdx &gt;= n) &#123;</span><br><span class="line">              midIdx -= n;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (nextIdx &gt;= n) &#123;</span><br><span class="line">              nextIdx -= n;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            points.<span class="title function_">getPoint</span>(poly[prevIdx], p1);</span><br><span class="line">            points.<span class="title function_">getPoint</span>(poly[midIdx], p2);</span><br><span class="line">            points.<span class="title function_">getPoint</span>(poly[nextIdx], p3);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="title function_">vtkCCSVectorProgression</span>(point, p1, p2, p3, normal) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">              foundMatch = <span class="literal">true</span>;</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            foundMatch = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (foundMatch) &#123;</span><br><span class="line">      splitCount++;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Split off a new poly</span></span><br><span class="line">      <span class="keyword">const</span> m = idx2 - idx1;</span><br><span class="line">      <span class="keyword">const</span> oldPoly = polys[i];</span><br><span class="line">      <span class="keyword">const</span> oldEdges = polyEdges[i];</span><br><span class="line">      <span class="keyword">const</span> newPoly1 = oldPoly.<span class="title function_">slice</span>(idx1, idx1 + m + unique);</span><br><span class="line">      <span class="keyword">const</span> newEdges1 = oldEdges.<span class="title function_">slice</span>(idx1, idx1 + m + unique);</span><br><span class="line">      <span class="keyword">const</span> newPoly2 = <span class="keyword">new</span> <span class="title class_">Array</span>(n - m + unique);</span><br><span class="line">      <span class="keyword">const</span> newEdges2 = <span class="keyword">new</span> <span class="title class_">Array</span>(n - m + unique);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (unique) &#123;</span><br><span class="line">        newEdges1[m] = -<span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// The poly that is split off, which might have more intersections</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; idx1 + unique; j++) &#123;</span><br><span class="line">        newPoly2[j] = oldPoly[j];</span><br><span class="line">        newEdges2[j] = oldEdges[j];</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (unique) &#123;</span><br><span class="line">        newEdges2[idx1] = -<span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> k = idx2; k &lt; n; k++) &#123;</span><br><span class="line">        newPoly2[k - m + unique] = oldPoly[k];</span><br><span class="line">        newEdges2[k - m + unique] = oldEdges[k];</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      polys[i] = newPoly1;</span><br><span class="line">      polyEdges[i] = newEdges1;</span><br><span class="line">      polys.<span class="title function_">push</span>(newPoly2);</span><br><span class="line">      polyEdges.<span class="title function_">push</span>(newEdges2);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Unless polygroup was clear (because poly was reversed),</span></span><br><span class="line">      <span class="comment">// make a group with one entry for the new poly</span></span><br><span class="line">      polyGroups.<span class="property">length</span> = polys.<span class="property">length</span>;</span><br><span class="line">      <span class="keyword">if</span> (polyGroups[i].<span class="property">length</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        polyGroups[polys.<span class="property">length</span> - <span class="number">1</span>].<span class="title function_">push</span>(polys.<span class="property">length</span> - <span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> splitCount;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ---------------------------------------------------</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The polygons might have a lot of extra points, i.e. points</span></span><br><span class="line"><span class="comment"> * in the middle of the edges.  Remove those points, but keep</span></span><br><span class="line"><span class="comment"> * the original edges as polylines in the originalEdges array.</span></span><br><span class="line"><span class="comment"> * Only original edges with more than two points will be kept.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Array[]</span>&#125; <span class="variable">polys</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">vtkPoints</span>&#125; <span class="variable">points</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Array</span>&#125; <span class="variable">polyEdges</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Array</span>&#125; <span class="variable">originalEdges</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">vtkCCSFindTrueEdges</span>(<span class="params">polys, points, polyEdges, originalEdges</span>) &#123;</span><br><span class="line">  <span class="comment">// Tolerance^2 for angle to see if line segments are parallel</span></span><br><span class="line">  <span class="keyword">const</span> atol2 = <span class="variable constant_">CCS_POLYGON_TOLERANCE</span> * <span class="variable constant_">CCS_POLYGON_TOLERANCE</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> p0 = [];</span><br><span class="line">  <span class="keyword">const</span> p1 = [];</span><br><span class="line">  <span class="keyword">const</span> p2 = [];</span><br><span class="line">  <span class="keyword">const</span> v1 = [];</span><br><span class="line">  <span class="keyword">const</span> v2 = [];</span><br><span class="line">  <span class="keyword">let</span> l1;</span><br><span class="line">  <span class="keyword">let</span> l2;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> polyId = <span class="number">0</span>; polyId &lt; polys.<span class="property">length</span>; polyId++) &#123;</span><br><span class="line">    <span class="keyword">const</span> oldPoly = polys[polyId];</span><br><span class="line">    <span class="keyword">const</span> n = oldPoly.<span class="property">length</span>;</span><br><span class="line">    <span class="keyword">const</span> newEdges = [];</span><br><span class="line">    polyEdges.<span class="title function_">push</span>(newEdges);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Only useful if poly has more than three sides</span></span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">4</span>) &#123;</span><br><span class="line">      newEdges[<span class="number">0</span>] = -<span class="number">1</span>;</span><br><span class="line">      newEdges[<span class="number">1</span>] = -<span class="number">1</span>;</span><br><span class="line">      newEdges[<span class="number">2</span>] = -<span class="number">1</span>;</span><br><span class="line">      <span class="comment">// eslint-disable-next-line no-continue</span></span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// While we remove points, m keeps track of how many points are left</span></span><br><span class="line">    <span class="keyword">let</span> m = n;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Compute bounds for tolerance</span></span><br><span class="line">    <span class="keyword">const</span> bounds = [];</span><br><span class="line">    <span class="keyword">const</span> tol2 = vtkPolygon.<span class="title function_">getBounds</span>(oldPoly, points, bounds) * atol2;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The new poly</span></span><br><span class="line">    <span class="keyword">const</span> newPoly = [];</span><br><span class="line">    <span class="keyword">let</span> cornerPointId = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> oldOriginalId = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Keep the partial edge from before the first corner is found</span></span><br><span class="line">    <span class="keyword">const</span> partialEdge = [];</span><br><span class="line">    <span class="keyword">let</span> cellCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    points.<span class="title function_">getPoint</span>(oldPoly[n - <span class="number">1</span>], p0);</span><br><span class="line">    points.<span class="title function_">getPoint</span>(oldPoly[<span class="number">0</span>], p1);</span><br><span class="line">    vtkMath.<span class="title function_">subtract</span>(p1, p0, v1);</span><br><span class="line">    l1 = vtkMath.<span class="title function_">dot</span>(v1, v1);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">      <span class="keyword">let</span> k = j + <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span> (k &gt;= n) &#123;</span><br><span class="line">        k -= n;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      points.<span class="title function_">getPoint</span>(oldPoly[k], p2);</span><br><span class="line">      vtkMath.<span class="title function_">subtract</span>(p2, p1, v2);</span><br><span class="line">      l2 = vtkMath.<span class="title function_">dot</span>(v2, v2);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Dot product is |v1||v2|cos(theta)</span></span><br><span class="line">      <span class="keyword">const</span> c = vtkMath.<span class="title function_">dot</span>(v1, v2);</span><br><span class="line">      <span class="comment">// sin^2(theta) = (1 - cos^2(theta))</span></span><br><span class="line">      <span class="comment">// and   c*c = l1*l2*cos^2(theta)</span></span><br><span class="line">      <span class="keyword">const</span> s2 = l1 * l2 - c * c;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// In the small angle approximation, sin(theta) == theta, so</span></span><br><span class="line">      <span class="comment">// s2/(l1*l2) is the angle that we want to check, but it&#x27;s not</span></span><br><span class="line">      <span class="comment">// a valid check if l1 or l2 is very close to zero.</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">const</span> pointId = oldPoly[j];</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Keep the point if:</span></span><br><span class="line">      <span class="comment">// 1) removing it would create a 2-point poly OR</span></span><br><span class="line">      <span class="comment">// 2) it&#x27;s more than &quot;tol&quot; distance from the prev point AND</span></span><br><span class="line">      <span class="comment">// 3) the angle is greater than atol:</span></span><br><span class="line">      <span class="keyword">if</span> (</span><br><span class="line">        m &lt;= <span class="number">3</span> ||</span><br><span class="line">        (l1 &gt; tol2 &amp;&amp; (c &lt; <span class="number">0</span> || l1 &lt; tol2 || l2 &lt; tol2 || s2 &gt; l1 * l2 * atol2))</span><br><span class="line">      ) &#123;</span><br><span class="line">        <span class="comment">// Complete the previous edge only if the final point count</span></span><br><span class="line">        <span class="comment">// will be greater than two</span></span><br><span class="line">        <span class="keyword">if</span> (cellCount &gt; <span class="number">1</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span> (pointId !== oldOriginalId) &#123;</span><br><span class="line">            originalEdges.<span class="title function_">push</span>(pointId);</span><br><span class="line">            cellCount++;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// Update the number of segments in the edge</span></span><br><span class="line">          <span class="keyword">const</span> countLocation = originalEdges.<span class="property">length</span> - cellCount - <span class="number">1</span>;</span><br><span class="line">          originalEdges[countLocation] = cellCount;</span><br><span class="line">          newEdges.<span class="title function_">push</span>(countLocation);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cellCount === <span class="number">0</span>) &#123;</span><br><span class="line">          partialEdge.<span class="title function_">push</span>(pointId);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          newEdges.<span class="title function_">push</span>(-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        newPoly.<span class="title function_">push</span>(pointId);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Start a new edge with cornerPointId as a &quot;virtual&quot; point</span></span><br><span class="line">        cornerPointId = pointId;</span><br><span class="line">        oldOriginalId = pointId;</span><br><span class="line">        cellCount = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Rotate to the next point</span></span><br><span class="line">        p0[<span class="number">0</span>] = p2[<span class="number">0</span>];</span><br><span class="line">        p0[<span class="number">1</span>] = p2[<span class="number">1</span>];</span><br><span class="line">        p0[<span class="number">2</span>] = p2[<span class="number">2</span>];</span><br><span class="line">        p1[<span class="number">0</span>] = p2[<span class="number">0</span>];</span><br><span class="line">        p1[<span class="number">1</span>] = p2[<span class="number">1</span>];</span><br><span class="line">        p1[<span class="number">2</span>] = p2[<span class="number">2</span>];</span><br><span class="line">        v1[<span class="number">0</span>] = v2[<span class="number">0</span>];</span><br><span class="line">        v1[<span class="number">1</span>] = v2[<span class="number">1</span>];</span><br><span class="line">        v1[<span class="number">2</span>] = v2[<span class="number">2</span>];</span><br><span class="line">        l1 = l2;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (cellCount &gt; <span class="number">0</span> &amp;&amp; pointId !== oldOriginalId) &#123;</span><br><span class="line">          <span class="comment">// First check to see if we have to add cornerPointId</span></span><br><span class="line">          <span class="keyword">if</span> (cellCount === <span class="number">1</span>) &#123;</span><br><span class="line">            originalEdges.<span class="title function_">push</span>(<span class="number">1</span>); <span class="comment">// new edge</span></span><br><span class="line">            originalEdges.<span class="title function_">push</span>(cornerPointId);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// Then add the new point</span></span><br><span class="line">          originalEdges.<span class="title function_">push</span>(pointId);</span><br><span class="line">          oldOriginalId = pointId;</span><br><span class="line">          cellCount++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// No corner yet, so save the point</span></span><br><span class="line">          partialEdge.<span class="title function_">push</span>(pointId);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Reduce the count</span></span><br><span class="line">        m--;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Join the previous two segments, since the point was removed</span></span><br><span class="line">        p1[<span class="number">0</span>] = p2[<span class="number">0</span>];</span><br><span class="line">        p1[<span class="number">1</span>] = p2[<span class="number">1</span>];</span><br><span class="line">        p1[<span class="number">2</span>] = p2[<span class="number">2</span>];</span><br><span class="line">        vtkMath.<span class="title function_">subtract</span>(p2, p0, v1);</span><br><span class="line">        l1 = vtkMath.<span class="title function_">dot</span>(v1, v1);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Add the partial edge to the end</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> ii = <span class="number">0</span>; ii &lt; partialEdge.<span class="property">length</span>; ii++) &#123;</span><br><span class="line">      <span class="keyword">const</span> pointId = partialEdge[ii];</span><br><span class="line">      <span class="keyword">if</span> (pointId !== oldOriginalId) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cellCount === <span class="number">1</span>) &#123;</span><br><span class="line">          originalEdges.<span class="title function_">push</span>(<span class="number">1</span>); <span class="comment">// new edge</span></span><br><span class="line">          originalEdges.<span class="title function_">push</span>(cornerPointId);</span><br><span class="line">        &#125;</span><br><span class="line">        originalEdges.<span class="title function_">push</span>(pointId);</span><br><span class="line">        oldOriginalId = pointId;</span><br><span class="line">        cellCount++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Finalize</span></span><br><span class="line">    <span class="keyword">if</span> (cellCount &gt; <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="comment">// Update the number of segments in the edge</span></span><br><span class="line">      <span class="keyword">const</span> countLocation = originalEdges.<span class="property">length</span> - cellCount - <span class="number">1</span>;</span><br><span class="line">      originalEdges[countLocation] = cellCount;</span><br><span class="line">      newEdges.<span class="title function_">push</span>(countLocation);</span><br><span class="line">    &#125;</span><br><span class="line">    polys[polyId] = newPoly;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ---------------------------------------------------</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Reverse a cleaned-up polygon along with the info about</span></span><br><span class="line"><span class="comment"> * all of its original vertices.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Array</span>&#125; <span class="variable">poly</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Array</span>&#125; <span class="variable">edges</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Array</span>&#125; <span class="variable">originalEdges</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">vtkCCSReversePoly</span>(<span class="params">poly, edges, originalEdges</span>) &#123;</span><br><span class="line">  <span class="title function_">reverseElements</span>(poly, <span class="number">1</span>, poly.<span class="property">length</span> - <span class="number">1</span>);</span><br><span class="line">  edges.<span class="title function_">reverse</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; edges.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (edges[i] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> firstPtsIdx = edges[i] + <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">const</span> npts = originalEdges[edges[i]];</span><br><span class="line">      <span class="title function_">reverseElements</span>(originalEdges, firstPtsIdx, firstPtsIdx + npts - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ---------------------------------------------------</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Check the sense of the polygon against the given normal. Returns</span></span><br><span class="line"><span class="comment"> * zero if the normal is zero.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Array</span>&#125; <span class="variable">poly</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">vtkPoints</span>&#125; <span class="variable">points</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Vector3</span>&#125; <span class="variable">normal</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">vtkCCSCheckPolygonSense</span>(<span class="params">poly, points, normal</span>) &#123;</span><br><span class="line">  <span class="comment">// Compute the normal</span></span><br><span class="line">  <span class="keyword">const</span> pnormal = [<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>];</span><br><span class="line">  <span class="keyword">const</span> p0 = [];</span><br><span class="line">  <span class="keyword">const</span> p1 = [];</span><br><span class="line">  <span class="keyword">const</span> p2 = [];</span><br><span class="line">  <span class="keyword">const</span> v1 = [];</span><br><span class="line">  <span class="keyword">const</span> v2 = [];</span><br><span class="line">  <span class="keyword">const</span> v = [];</span><br><span class="line"></span><br><span class="line">  points.<span class="title function_">getPoint</span>(poly[<span class="number">0</span>], p0);</span><br><span class="line">  points.<span class="title function_">getPoint</span>(poly[<span class="number">1</span>], p1);</span><br><span class="line">  vtkMath.<span class="title function_">subtract</span>(p1, p0, v1);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> jj = <span class="number">2</span>; jj &lt; poly.<span class="property">length</span>; jj++) &#123;</span><br><span class="line">    points.<span class="title function_">getPoint</span>(poly[jj], p2);</span><br><span class="line">    vtkMath.<span class="title function_">subtract</span>(p2, p0, v2);</span><br><span class="line">    vtkMath.<span class="title function_">cross</span>(v1, v2, v);</span><br><span class="line">    vtkMath.<span class="title function_">add</span>(pnormal, v, pnormal);</span><br><span class="line">    p1[<span class="number">0</span>] = p2[<span class="number">0</span>];</span><br><span class="line">    p1[<span class="number">1</span>] = p2[<span class="number">1</span>];</span><br><span class="line">    p1[<span class="number">2</span>] = p2[<span class="number">2</span>];</span><br><span class="line">    v1[<span class="number">0</span>] = v2[<span class="number">0</span>];</span><br><span class="line">    v1[<span class="number">1</span>] = v2[<span class="number">1</span>];</span><br><span class="line">    v1[<span class="number">2</span>] = v2[<span class="number">2</span>];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Check the normal</span></span><br><span class="line">  <span class="keyword">const</span> d = vtkMath.<span class="title function_">dot</span>(pnormal, normal);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123; <span class="attr">isNormalNotZero</span>: d !== <span class="number">0</span>, <span class="attr">sense</span>: d &gt; <span class="number">0</span> &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ---------------------------------------------------</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Check whether innerPoly is inside outerPoly.</span></span><br><span class="line"><span class="comment"> * The normal is needed to verify the polygon orientation.</span></span><br><span class="line"><span class="comment"> * The values of pp, bounds, and tol2 must be precomputed</span></span><br><span class="line"><span class="comment"> * by calling vtkCCSPrepareForPolyInPoly() on outerPoly.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Array</span>&#125; <span class="variable">outerPoly</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Array</span>&#125; <span class="variable">innerPoly</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">vtkPoints</span>&#125; <span class="variable">points</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Vector3</span>&#125; <span class="variable">normal</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Float64Array</span>&#125; <span class="variable">pp</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Bounds</span>&#125; <span class="variable">bounds</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Number</span>&#125; <span class="variable">tol2</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">vtkCCSPolyInPoly</span>(<span class="params"></span></span><br><span class="line"><span class="params">  outerPoly,</span></span><br><span class="line"><span class="params">  innerPoly,</span></span><br><span class="line"><span class="params">  points,</span></span><br><span class="line"><span class="params">  normal,</span></span><br><span class="line"><span class="params">  pp,</span></span><br><span class="line"><span class="params">  bounds,</span></span><br><span class="line"><span class="params">  tol2</span></span><br><span class="line"><span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// Find a vertex of poly &quot;j&quot; that isn&#x27;t on the edge of poly &quot;i&quot;.</span></span><br><span class="line">  <span class="comment">// This is necessary or the PointInPolygon might return &quot;true&quot;</span></span><br><span class="line">  <span class="comment">// based only on roundoff error.</span></span><br><span class="line">  <span class="keyword">const</span> n = outerPoly.<span class="property">length</span>;</span><br><span class="line">  <span class="keyword">const</span> m = innerPoly.<span class="property">length</span>;</span><br><span class="line">  <span class="keyword">const</span> p = [];</span><br><span class="line">  <span class="keyword">const</span> q1 = [];</span><br><span class="line">  <span class="keyword">const</span> q2 = [];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> jj = <span class="number">0</span>; jj &lt; m; jj++) &#123;</span><br><span class="line">    <span class="comment">// Semi-randomize the point order</span></span><br><span class="line">    <span class="comment">// eslint-disable-next-line no-bitwise</span></span><br><span class="line">    <span class="keyword">const</span> kk = (jj &gt;&gt; <span class="number">1</span>) + (jj &amp; <span class="number">1</span>) * ((m + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    points.<span class="title function_">getPoint</span>(innerPoly[kk], p);</span><br><span class="line">    <span class="keyword">const</span> intersectionState = vtkPolygon.<span class="title function_">pointInPolygon</span>(p, pp, bounds, normal);</span><br><span class="line">    <span class="keyword">if</span> (intersectionState === <span class="title class_">PolygonWithPointIntersectionState</span>.<span class="property">FAILURE</span>) &#123;</span><br><span class="line">      <span class="title function_">vtkErrorMacro</span>(<span class="string">&#x27;Error finding point in polygon in vtkCCSPolyInPoly&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (intersectionState !== <span class="title class_">PolygonWithPointIntersectionState</span>.<span class="property">OUTSIDE</span>) &#123;</span><br><span class="line">      <span class="keyword">let</span> pointOnEdge = <span class="number">0</span>;</span><br><span class="line">      points.<span class="title function_">getPoint</span>(outerPoly[n - <span class="number">1</span>], q1);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> ii = <span class="number">0</span>; ii &lt; n; ii++) &#123;</span><br><span class="line">        points.<span class="title function_">getPoint</span>(outerPoly[ii], q2);</span><br><span class="line">        <span class="comment">// This method returns distance squared</span></span><br><span class="line">        <span class="keyword">const</span> &#123; distance &#125; = vtkLine.<span class="title function_">distanceToLine</span>(p, q1, q2);</span><br><span class="line">        <span class="keyword">if</span> (distance &lt; tol2) &#123;</span><br><span class="line">          pointOnEdge = <span class="number">1</span>;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        q1[<span class="number">0</span>] = q2[<span class="number">0</span>];</span><br><span class="line">        q1[<span class="number">1</span>] = q2[<span class="number">1</span>];</span><br><span class="line">        q1[<span class="number">2</span>] = q2[<span class="number">2</span>];</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!pointOnEdge) &#123;</span><br><span class="line">        <span class="comment">// Good result, point is in polygon</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// No matches found</span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ---------------------------------------------------</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Precompute values needed for the PolyInPoly check.</span></span><br><span class="line"><span class="comment"> * The values that are returned are as follows:</span></span><br><span class="line"><span class="comment"> * pp: an array of the polygon vertices</span></span><br><span class="line"><span class="comment"> * bounds: the polygon bounds</span></span><br><span class="line"><span class="comment"> * tol2: a tolerance value based on the size of the polygon</span></span><br><span class="line"><span class="comment"> * (note: pp must be pre-allocated to the 3*outerPoly.length)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Array</span>&#125; <span class="variable">outerPoly</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">vtkPoints</span>&#125; <span class="variable">points</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Float64Array</span>&#125; <span class="variable">pp</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Bounds</span>&#125; <span class="variable">bounds</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">vtkCCSPrepareForPolyInPoly</span>(<span class="params">outerPoly, points, pp, bounds</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> n = outerPoly.<span class="property">length</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (n === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0.0</span>; <span class="comment">// to avoid false positive warning about uninitialized value</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Pull out the points</span></span><br><span class="line">  <span class="keyword">const</span> point = [];</span><br><span class="line">  <span class="keyword">let</span> j = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    points.<span class="title function_">getPoint</span>(outerPoly[i], point);</span><br><span class="line">    pp[j++] = point[<span class="number">0</span>];</span><br><span class="line">    pp[j++] = point[<span class="number">1</span>];</span><br><span class="line">    pp[j++] = point[<span class="number">2</span>];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Find the bounding box and tolerance for the polygon</span></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    vtkPolygon.<span class="title function_">getBounds</span>(outerPoly, points, bounds) *</span><br><span class="line">    (<span class="variable constant_">CCS_POLYGON_TOLERANCE</span> * <span class="variable constant_">CCS_POLYGON_TOLERANCE</span>)</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ---------------------------------------------------</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Check for polygons within polygons. Group the polygons</span></span><br><span class="line"><span class="comment"> * if they are within each other. Reverse the sense of</span></span><br><span class="line"><span class="comment"> * the interior &quot;hole&quot; polygons. A hole within a hole</span></span><br><span class="line"><span class="comment"> * will be reversed twice and will become its own group.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Array</span>&#125; <span class="variable">newPolys</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">vtkPoints</span>&#125; <span class="variable">points</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Array</span>&#125; <span class="variable">polyGroups</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Array</span>&#125; <span class="variable">polyEdges</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Array</span>&#125; <span class="variable">originalEdges</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Vector3</span>&#125; <span class="variable">normal</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Boolean</span>&#125; <span class="variable">oriented</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">vtkCCSMakeHoleyPolys</span>(<span class="params"></span></span><br><span class="line"><span class="params">  newPolys,</span></span><br><span class="line"><span class="params">  points,</span></span><br><span class="line"><span class="params">  polyGroups,</span></span><br><span class="line"><span class="params">  polyEdges,</span></span><br><span class="line"><span class="params">  originalEdges,</span></span><br><span class="line"><span class="params">  normal,</span></span><br><span class="line"><span class="params">  oriented</span></span><br><span class="line"><span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> numNewPolys = newPolys.<span class="property">length</span>;</span><br><span class="line">  <span class="keyword">if</span> (numNewPolys &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Use bit arrays to keep track of inner polys</span></span><br><span class="line">  <span class="keyword">const</span> polyReversed = [];</span><br><span class="line">  <span class="keyword">const</span> innerPolys = [];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// GroupCount is an array only needed for unoriented polys</span></span><br><span class="line">  <span class="keyword">let</span> groupCount;</span><br><span class="line">  <span class="keyword">if</span> (!oriented) &#123;</span><br><span class="line">    groupCount = <span class="keyword">new</span> <span class="title class_">Int32Array</span>(numNewPolys);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Find the maximum poly size</span></span><br><span class="line">  <span class="keyword">let</span> nmax = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> kk = <span class="number">0</span>; kk &lt; numNewPolys; kk++) &#123;</span><br><span class="line">    nmax = <span class="title class_">Math</span>.<span class="title function_">max</span>(nmax, newPolys[kk].<span class="property">length</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// These are some values needed for poly-in-poly checks</span></span><br><span class="line">  <span class="keyword">const</span> pp = <span class="keyword">new</span> <span class="title class_">Float64Array</span>(<span class="number">3</span> * nmax);</span><br><span class="line">  <span class="keyword">const</span> bounds = [<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>];</span><br><span class="line">  <span class="keyword">let</span> tol2;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Go through all polys</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; numNewPolys; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> n = newPolys[i].<span class="property">length</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">3</span>) &#123;</span><br><span class="line">      <span class="comment">// eslint-disable-next-line no-continue</span></span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check if poly is reversed</span></span><br><span class="line">    <span class="keyword">const</span> &#123; isNormalNotZero, sense &#125; = <span class="title function_">vtkCCSCheckPolygonSense</span>(</span><br><span class="line">      newPolys[i],</span><br><span class="line">      points,</span><br><span class="line">      normal</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">if</span> (isNormalNotZero) &#123;</span><br><span class="line">      polyReversed[i] = !sense;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Precompute some values needed for poly-in-poly checks</span></span><br><span class="line">    tol2 = <span class="title function_">vtkCCSPrepareForPolyInPoly</span>(newPolys[i], points, pp, bounds);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Look for polygons inside of this one</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; numNewPolys; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (j !== i &amp;&amp; newPolys[j].<span class="property">length</span> &gt;= <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="comment">// Make sure polygon i is not in polygon j</span></span><br><span class="line">        <span class="keyword">const</span> pg = polyGroups[j];</span><br><span class="line">        <span class="keyword">if</span> (!pg.<span class="title function_">includes</span>(i)) &#123;</span><br><span class="line">          <span class="keyword">if</span> (</span><br><span class="line">            <span class="title function_">vtkCCSPolyInPoly</span>(</span><br><span class="line">              newPolys[i],</span><br><span class="line">              newPolys[j],</span><br><span class="line">              points,</span><br><span class="line">              normal,</span><br><span class="line">              pp.<span class="title function_">subarray</span>(<span class="number">3</span> * n),</span><br><span class="line">              bounds,</span><br><span class="line">              tol2</span><br><span class="line">            )</span><br><span class="line">          ) &#123;</span><br><span class="line">            <span class="comment">// Add to group</span></span><br><span class="line">            polyGroups[i].<span class="title function_">push</span>(j);</span><br><span class="line">            <span class="keyword">if</span> (groupCount) &#123;</span><br><span class="line">              groupCount[j] += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!oriented) &#123;</span><br><span class="line">    <span class="comment">// build a stack of polys that aren&#x27;t inside other polys=</span></span><br><span class="line">    <span class="keyword">const</span> outerPolyStack = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> ll = <span class="number">0</span>; ll &lt; numNewPolys; ll++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (groupCount[ll] === <span class="number">0</span>) &#123;</span><br><span class="line">        outerPolyStack.<span class="title function_">push</span>(ll);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> j;</span><br><span class="line">    <span class="keyword">while</span> (outerPolyStack.<span class="property">length</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      j = outerPolyStack.<span class="property">length</span> - <span class="number">1</span>;</span><br><span class="line">      outerPolyStack.<span class="title function_">pop</span>();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (polyReversed[j]) &#123;</span><br><span class="line">        <span class="title function_">vtkCCSReversePoly</span>(newPolys[j], polyEdges[j], originalEdges);</span><br><span class="line">        polyReversed[j] = <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (polyGroups[j].<span class="property">length</span> &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// Convert the group into a bit array, to make manipulation easier</span></span><br><span class="line">        innerPolys.<span class="property">length</span> = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> k = <span class="number">1</span>; k &lt; polyGroups[j].<span class="property">length</span>; k++) &#123;</span><br><span class="line">          <span class="keyword">const</span> jj = polyGroups[j][k];</span><br><span class="line">          <span class="keyword">if</span> (groupCount[jj] &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            groupCount[jj] -= <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (groupCount[jj] === <span class="number">0</span>) &#123;</span><br><span class="line">              outerPolyStack.<span class="title function_">push</span>(jj);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            innerPolys[jj] = <span class="number">1</span>;</span><br><span class="line">            polyGroups[jj].<span class="property">length</span> = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (!polyReversed[jj]) &#123;</span><br><span class="line">              <span class="title function_">vtkCCSReversePoly</span>(newPolys[jj], polyEdges[jj], originalEdges);</span><br><span class="line">              polyReversed[jj] = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Use the bit array to recreate the polyGroup</span></span><br><span class="line">        polyGroups[j].<span class="property">length</span> = <span class="number">0</span>;</span><br><span class="line">        polyGroups[j].<span class="title function_">push</span>(j);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> jj = <span class="number">0</span>; jj &lt; numNewPolys; jj++) &#123;</span><br><span class="line">          <span class="keyword">if</span> (innerPolys[jj]) &#123;</span><br><span class="line">            polyGroups[j].<span class="title function_">push</span>(jj);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// oriented</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; numNewPolys; j++) &#123;</span><br><span class="line">      <span class="comment">// Remove the groups for reversed polys</span></span><br><span class="line">      <span class="keyword">if</span> (polyReversed[j]) &#123;</span><br><span class="line">        polyGroups[j].<span class="property">length</span> = <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// Polys inside the interior polys have their own groups, so remove</span></span><br><span class="line">      <span class="comment">// them from this group</span></span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (polyGroups[j].<span class="property">length</span> &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// Convert the group into a bit array, to make manipulation easier</span></span><br><span class="line">        innerPolys.<span class="property">length</span> = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> k = <span class="number">1</span>; k &lt; polyGroups[j].<span class="property">length</span>; k++) &#123;</span><br><span class="line">          innerPolys[polyGroups[j][k]] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Look for non-reversed polys inside this one</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> kk = <span class="number">1</span>; kk &lt; polyGroups[j].<span class="property">length</span>; kk++) &#123;</span><br><span class="line">          <span class="comment">// jj is the index of the inner poly</span></span><br><span class="line">          <span class="keyword">const</span> jj = polyGroups[j][kk];</span><br><span class="line">          <span class="comment">// If inner poly is not reversed then</span></span><br><span class="line">          <span class="keyword">if</span> (!polyReversed[jj]) &#123;</span><br><span class="line">            <span class="comment">// Remove that poly and all polys inside of it from the group</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> ii = <span class="number">0</span>; ii &lt; polyGroups[jj].<span class="property">length</span>; ii++) &#123;</span><br><span class="line">              innerPolys[polyGroups[jj][ii]] = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Use the bit array to recreate the polyGroup</span></span><br><span class="line">        polyGroups[j].<span class="property">length</span> = <span class="number">0</span>;</span><br><span class="line">        polyGroups[j].<span class="title function_">push</span>(j);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> jj = <span class="number">0</span>; jj &lt; numNewPolys; jj++) &#123;</span><br><span class="line">          <span class="keyword">if</span> (innerPolys[jj]) &#123;</span><br><span class="line">            polyGroups[j].<span class="title function_">push</span>(jj);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// delete[] groupCount;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ---------------------------------------------------</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Check line segment with point Ids (i, j) to make sure that it</span></span><br><span class="line"><span class="comment"> * doesn&#x27;t cut through the edges of any polys in the group.</span></span><br><span class="line"><span class="comment"> * Return value of zero means check failed and the cut is not</span></span><br><span class="line"><span class="comment"> * usable.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Array[]</span>&#125; <span class="variable">polys</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">vtkPoints</span>&#125; <span class="variable">points</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Vector3</span>&#125; <span class="variable">normal</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Array</span>&#125; <span class="variable">polyGroup</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Number</span>&#125; <span class="variable">outerPolyId</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Number</span>&#125; <span class="variable">innerPolyId</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Number</span>&#125; <span class="variable">outerIdx</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Number</span>&#125; <span class="variable">innerIdx</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">vtkCCSCheckCut</span>(<span class="params"></span></span><br><span class="line"><span class="params">  polys,</span></span><br><span class="line"><span class="params">  points,</span></span><br><span class="line"><span class="params">  normal,</span></span><br><span class="line"><span class="params">  polyGroup,</span></span><br><span class="line"><span class="params">  outerPolyId,</span></span><br><span class="line"><span class="params">  innerPolyId,</span></span><br><span class="line"><span class="params">  outerIdx,</span></span><br><span class="line"><span class="params">  innerIdx</span></span><br><span class="line"><span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> ptId1 = polys[outerPolyId][outerIdx];</span><br><span class="line">  <span class="keyword">const</span> ptId2 = polys[innerPolyId][innerIdx];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> tol = <span class="variable constant_">CCS_POLYGON_TOLERANCE</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> p1 = [];</span><br><span class="line">  <span class="keyword">const</span> p2 = [];</span><br><span class="line">  points.<span class="title function_">getPoint</span>(ptId1, p1);</span><br><span class="line">  points.<span class="title function_">getPoint</span>(ptId2, p2);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> w = [];</span><br><span class="line">  vtkMath.<span class="title function_">subtract</span>(p2, p1, w);</span><br><span class="line">  <span class="keyword">const</span> l = vtkMath.<span class="title function_">normalize</span>(w);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Cuts between coincident points are good</span></span><br><span class="line">  <span class="keyword">if</span> (l === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Define a tolerance with units of distance squared</span></span><br><span class="line">  <span class="keyword">const</span> tol2 = l * l * tol * tol;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Check the sense of the cut: it must be pointing &quot;in&quot; for both polys.</span></span><br><span class="line">  <span class="keyword">let</span> polyId = outerPolyId;</span><br><span class="line">  <span class="keyword">let</span> polyIdx = outerIdx;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> r = p1;</span><br><span class="line">  <span class="keyword">const</span> r1 = [];</span><br><span class="line">  <span class="keyword">let</span> r2 = p2;</span><br><span class="line">  <span class="keyword">const</span> r3 = [];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> ii = <span class="number">0</span>; ii &lt; <span class="number">2</span>; ii++) &#123;</span><br><span class="line">    <span class="keyword">const</span> poly = polys[polyId];</span><br><span class="line">    <span class="keyword">const</span> n = poly.<span class="property">length</span>;</span><br><span class="line">    <span class="keyword">let</span> prevIdx = n - polyIdx - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> nextIdx = polyIdx + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (prevIdx &gt;= n) &#123;</span><br><span class="line">      prevIdx -= n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (nextIdx &gt;= n) &#123;</span><br><span class="line">      nextIdx -= n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    points.<span class="title function_">getPoint</span>(poly[prevIdx], r1);</span><br><span class="line">    points.<span class="title function_">getPoint</span>(poly[nextIdx], r3);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">vtkCCSVectorProgression</span>(r, r1, r2, r3, normal) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    polyId = innerPolyId;</span><br><span class="line">    polyIdx = innerIdx;</span><br><span class="line">    r = p2;</span><br><span class="line">    r2 = p1;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Check for intersections of the cut with polygon edges.</span></span><br><span class="line">  <span class="comment">// First, create a cut plane that divides space at the cut line.</span></span><br><span class="line">  <span class="keyword">const</span> pc = [];</span><br><span class="line">  vtkMath.<span class="title function_">cross</span>(normal, w, pc);</span><br><span class="line">  pc[<span class="number">3</span>] = -vtkMath.<span class="title function_">dot</span>(pc, p1);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; polyGroup.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> poly = polys[polyGroup[i]];</span><br><span class="line">    <span class="keyword">const</span> n = poly.<span class="property">length</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> q1 = [];</span><br><span class="line">    <span class="keyword">const</span> q2 = [];</span><br><span class="line">    <span class="keyword">let</span> qtId1 = poly[n - <span class="number">1</span>];</span><br><span class="line">    points.<span class="title function_">getPoint</span>(qtId1, q1);</span><br><span class="line">    <span class="keyword">let</span> v1 = pc[<span class="number">0</span>] * q1[<span class="number">0</span>] + pc[<span class="number">1</span>] * q1[<span class="number">1</span>] + pc[<span class="number">2</span>] * q1[<span class="number">2</span>] + pc[<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">let</span> c1 = v1 &gt; <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">      <span class="keyword">const</span> qtId2 = poly[j];</span><br><span class="line">      points.<span class="title function_">getPoint</span>(qtId2, q2);</span><br><span class="line">      <span class="keyword">const</span> v2 = pc[<span class="number">0</span>] * q2[<span class="number">0</span>] + pc[<span class="number">1</span>] * q2[<span class="number">1</span>] + pc[<span class="number">2</span>] * q2[<span class="number">2</span>] + pc[<span class="number">3</span>];</span><br><span class="line">      <span class="keyword">const</span> c2 = v2 &gt; <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// If lines share an endpoint, they can&#x27;t intersect,</span></span><br><span class="line">      <span class="comment">// so don&#x27;t bother with the check.</span></span><br><span class="line">      <span class="keyword">if</span> (</span><br><span class="line">        ptId1 !== qtId1 &amp;&amp;</span><br><span class="line">        ptId1 !== qtId2 &amp;&amp;</span><br><span class="line">        ptId2 !== qtId1 &amp;&amp;</span><br><span class="line">        ptId2 !== qtId2</span><br><span class="line">      ) &#123;</span><br><span class="line">        <span class="comment">// Check for intersection</span></span><br><span class="line">        <span class="keyword">if</span> ((c1 ? !c2 : c2) || v1 * v1 &lt; tol2 || v2 * v2 &lt; tol2) &#123;</span><br><span class="line">          vtkMath.<span class="title function_">subtract</span>(q2, q1, w);</span><br><span class="line">          <span class="keyword">if</span> (vtkMath.<span class="title function_">dot</span>(w, w) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">const</span> qc = [];</span><br><span class="line">            vtkMath.<span class="title function_">cross</span>(w, normal, qc);</span><br><span class="line">            qc[<span class="number">3</span>] = -vtkMath.<span class="title function_">dot</span>(qc, q1);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> u1 = qc[<span class="number">0</span>] * p1[<span class="number">0</span>] + qc[<span class="number">1</span>] * p1[<span class="number">1</span>] + qc[<span class="number">2</span>] * p1[<span class="number">2</span>] + qc[<span class="number">3</span>];</span><br><span class="line">            <span class="keyword">const</span> u2 = qc[<span class="number">0</span>] * p2[<span class="number">0</span>] + qc[<span class="number">1</span>] * p2[<span class="number">1</span>] + qc[<span class="number">2</span>] * p2[<span class="number">2</span>] + qc[<span class="number">3</span>];</span><br><span class="line">            <span class="keyword">const</span> d1 = u1 &gt; <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">const</span> d2 = u2 &gt; <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (d1 ? !d2 : d2) &#123;</span><br><span class="line">              <span class="comment">// One final check to make sure endpoints aren&#x27;t coincident</span></span><br><span class="line">              <span class="keyword">let</span> p = p1;</span><br><span class="line">              <span class="keyword">let</span> q = q1;</span><br><span class="line">              <span class="keyword">if</span> (v2 * v2 &lt; v1 * v1) &#123;</span><br><span class="line">                p = p2;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">if</span> (u2 * u2 &lt; u1 * u1) &#123;</span><br><span class="line">                q = q2;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">if</span> (vtkMath.<span class="title function_">distance2BetweenPoints</span>(p, q) &gt; tol2) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      qtId1 = qtId2;</span><br><span class="line">      q1[<span class="number">0</span>] = q2[<span class="number">0</span>];</span><br><span class="line">      q1[<span class="number">1</span>] = q2[<span class="number">1</span>];</span><br><span class="line">      q1[<span class="number">2</span>] = q2[<span class="number">2</span>];</span><br><span class="line">      v1 = v2;</span><br><span class="line">      c1 = c2;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ---------------------------------------------------</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Check the quality of a cut between an outer and inner polygon.</span></span><br><span class="line"><span class="comment"> * An ideal cut is one that forms a 90 degree angle with each</span></span><br><span class="line"><span class="comment"> * line segment that it joins to.  Smaller values indicate a</span></span><br><span class="line"><span class="comment"> * higher quality cut.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Array</span>&#125; <span class="variable">outerPoly</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Array</span>&#125; <span class="variable">innerPoly</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Number</span>&#125; <span class="variable">i</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Number</span>&#125; <span class="variable">j</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">vtkPoints</span>&#125; <span class="variable">points</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">vtkCCSCutQuality</span>(<span class="params">outerPoly, innerPoly, i, j, points</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> n = outerPoly.<span class="property">length</span>;</span><br><span class="line">  <span class="keyword">const</span> m = innerPoly.<span class="property">length</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> a = i &gt; <span class="number">0</span> ? i - <span class="number">1</span> : n - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">const</span> b = i &lt; n - <span class="number">1</span> ? i + <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> c = j &gt; <span class="number">0</span> ? j - <span class="number">1</span> : m - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">const</span> d = j &lt; m - <span class="number">1</span> ? j + <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> p0 = [];</span><br><span class="line">  <span class="keyword">const</span> p1 = [];</span><br><span class="line">  <span class="keyword">const</span> p2 = [];</span><br><span class="line">  points.<span class="title function_">getPoint</span>(outerPoly[i], p1);</span><br><span class="line">  points.<span class="title function_">getPoint</span>(innerPoly[j], p2);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> v1 = [];</span><br><span class="line">  <span class="keyword">const</span> v2 = [];</span><br><span class="line">  vtkMath.<span class="title function_">subtract</span>(p2, p1, v1);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> l1 = vtkMath.<span class="title function_">dot</span>(v1, v1);</span><br><span class="line">  <span class="keyword">let</span> l2;</span><br><span class="line">  <span class="keyword">let</span> qmax = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> q;</span><br><span class="line"></span><br><span class="line">  points.<span class="title function_">getPoint</span>(outerPoly[a], p0);</span><br><span class="line">  vtkMath.<span class="title function_">subtract</span>(p0, p1, v2);</span><br><span class="line">  l2 = vtkMath.<span class="title function_">dot</span>(v2, v2);</span><br><span class="line">  <span class="keyword">if</span> (l2 &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    q = vtkMath.<span class="title function_">dot</span>(v1, v2);</span><br><span class="line">    q *= q / l2;</span><br><span class="line">    <span class="keyword">if</span> (q &gt; qmax) &#123;</span><br><span class="line">      qmax = q;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  points.<span class="title function_">getPoint</span>(outerPoly[b], p0);</span><br><span class="line">  vtkMath.<span class="title function_">subtract</span>(p0, p1, v2);</span><br><span class="line">  l2 = vtkMath.<span class="title function_">dot</span>(v2, v2);</span><br><span class="line">  <span class="keyword">if</span> (l2 &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    q = vtkMath.<span class="title function_">dot</span>(v1, v2);</span><br><span class="line">    q *= q / l2;</span><br><span class="line">    <span class="keyword">if</span> (q &gt; qmax) &#123;</span><br><span class="line">      qmax = q;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  points.<span class="title function_">getPoint</span>(innerPoly[c], p0);</span><br><span class="line">  vtkMath.<span class="title function_">subtract</span>(p2, p0, v2);</span><br><span class="line">  l2 = vtkMath.<span class="title function_">dot</span>(v2, v2);</span><br><span class="line">  <span class="keyword">if</span> (l2 &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    q = vtkMath.<span class="title function_">dot</span>(v1, v2);</span><br><span class="line">    q *= q / l2;</span><br><span class="line">    <span class="keyword">if</span> (q &gt; qmax) &#123;</span><br><span class="line">      qmax = q;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  points.<span class="title function_">getPoint</span>(innerPoly[d], p0);</span><br><span class="line">  vtkMath.<span class="title function_">subtract</span>(p2, p0, v2);</span><br><span class="line">  l2 = vtkMath.<span class="title function_">dot</span>(v2, v2);</span><br><span class="line">  <span class="keyword">if</span> (l2 &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    q = vtkMath.<span class="title function_">dot</span>(v1, v2);</span><br><span class="line">    q *= q / l2;</span><br><span class="line">    <span class="keyword">if</span> (q &gt; qmax) &#123;</span><br><span class="line">      qmax = q;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (l1 &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> qmax / l1; <span class="comment">// also l1 + qmax, incorporates distance;</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Number</span>.<span class="property">MAX_VALUE</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ---------------------------------------------------</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Find the two sharpest verts on an inner (i.e. inside-out) poly.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Array</span>&#125; <span class="variable">poly</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">vtkPoints</span>&#125; <span class="variable">points</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Vector3</span>&#125; <span class="variable">normal</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">[Number, Number]</span>&#125; <span class="variable">verts</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">vtkCCSFindSharpestVerts</span>(<span class="params">poly, points, normal, verts</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> p1 = [];</span><br><span class="line">  <span class="keyword">const</span> p2 = [];</span><br><span class="line">  <span class="keyword">const</span> v1 = [];</span><br><span class="line">  <span class="keyword">const</span> v2 = [];</span><br><span class="line">  <span class="keyword">const</span> v = [];</span><br><span class="line">  <span class="keyword">let</span> l1;</span><br><span class="line">  <span class="keyword">let</span> l2;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> minVal = [<span class="number">0</span>, <span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">  verts[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">  verts[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> n = poly.<span class="property">length</span>;</span><br><span class="line">  points.<span class="title function_">getPoint</span>(poly[n - <span class="number">1</span>], p2);</span><br><span class="line">  points.<span class="title function_">getPoint</span>(poly[<span class="number">0</span>], p1);</span><br><span class="line"></span><br><span class="line">  vtkMath.<span class="title function_">subtract</span>(p1, p2, v1);</span><br><span class="line">  l1 = <span class="title class_">Math</span>.<span class="title function_">sqrt</span>(vtkMath.<span class="title function_">dot</span>(v1, v1));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">    <span class="keyword">let</span> k = j + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (k === n) &#123;</span><br><span class="line">      k = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    points.<span class="title function_">getPoint</span>(poly[k], p2);</span><br><span class="line">    vtkMath.<span class="title function_">subtract</span>(p2, p1, v2);</span><br><span class="line">    l2 = <span class="title class_">Math</span>.<span class="title function_">sqrt</span>(vtkMath.<span class="title function_">dot</span>(v2, v2));</span><br><span class="line"></span><br><span class="line">    vtkMath.<span class="title function_">cross</span>(v1, v2, v);</span><br><span class="line">    <span class="keyword">const</span> b = vtkMath.<span class="title function_">dot</span>(v, normal);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (b &lt; <span class="number">0</span> &amp;&amp; l1 * l2 &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// Dot product is |v1||v2|cos(theta), range [-1, +1]</span></span><br><span class="line">      <span class="keyword">const</span> val = vtkMath.<span class="title function_">dot</span>(v1, v2) / (l1 * l2);</span><br><span class="line">      <span class="keyword">if</span> (val &lt; minVal[<span class="number">0</span>]) &#123;</span><br><span class="line">        minVal[<span class="number">1</span>] = minVal[<span class="number">0</span>];</span><br><span class="line">        minVal[<span class="number">0</span>] = val;</span><br><span class="line">        verts[<span class="number">1</span>] = verts[<span class="number">0</span>];</span><br><span class="line">        verts[<span class="number">0</span>] = j;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Rotate to the next point</span></span><br><span class="line">    p1[<span class="number">0</span>] = p2[<span class="number">0</span>];</span><br><span class="line">    p1[<span class="number">1</span>] = p2[<span class="number">1</span>];</span><br><span class="line">    p1[<span class="number">2</span>] = p2[<span class="number">2</span>];</span><br><span class="line">    v1[<span class="number">0</span>] = v2[<span class="number">0</span>];</span><br><span class="line">    v1[<span class="number">1</span>] = v2[<span class="number">1</span>];</span><br><span class="line">    v1[<span class="number">2</span>] = v2[<span class="number">2</span>];</span><br><span class="line">    l1 = l2;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ---------------------------------------------------</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Find two valid cuts between outerPoly and innerPoly.</span></span><br><span class="line"><span class="comment"> * Used by vtkCCSCutHoleyPolys.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Array</span>&#125; <span class="variable">polys</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Array</span>&#125; <span class="variable">polyGroup</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Number</span>&#125; <span class="variable">outerPolyId</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Number</span>&#125; <span class="variable">innerPolyId</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">vtkPoints</span>&#125; <span class="variable">points</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Vector3</span>&#125; <span class="variable">normal</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Array[]</span>&#125; <span class="variable">cuts</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Boolean</span>&#125; <span class="variable">exhaustive</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">vtkCCSFindCuts</span>(<span class="params"></span></span><br><span class="line"><span class="params">  polys,</span></span><br><span class="line"><span class="params">  polyGroup,</span></span><br><span class="line"><span class="params">  outerPolyId,</span></span><br><span class="line"><span class="params">  innerPolyId,</span></span><br><span class="line"><span class="params">  points,</span></span><br><span class="line"><span class="params">  normal,</span></span><br><span class="line"><span class="params">  cuts,</span></span><br><span class="line"><span class="params">  exhaustive</span></span><br><span class="line"><span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> outerPoly = polys[outerPolyId];</span><br><span class="line">  <span class="keyword">const</span> innerPoly = polys[innerPolyId];</span><br><span class="line">  <span class="keyword">const</span> innerSize = innerPoly.<span class="property">length</span>;</span><br><span class="line">  <span class="comment">// Find the two sharpest points on the inner poly</span></span><br><span class="line">  <span class="keyword">const</span> verts = [];</span><br><span class="line">  <span class="title function_">vtkCCSFindSharpestVerts</span>(innerPoly, points, normal, verts);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// A list of cut locations according to quality</span></span><br><span class="line">  <span class="keyword">const</span> cutlist = [];</span><br><span class="line">  cutlist.<span class="property">length</span> = outerPoly.<span class="property">length</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Search for potential cuts (need to find two cuts)</span></span><br><span class="line">  <span class="keyword">let</span> cutId = <span class="number">0</span>;</span><br><span class="line">  cuts[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">  cuts[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">  cuts[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">  cuts[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> foundCut = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">for</span> (cutId = <span class="number">0</span>; cutId &lt; <span class="number">2</span>; cutId++) &#123;</span><br><span class="line">    <span class="keyword">const</span> count = exhaustive ? innerSize : <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; count &amp;&amp; !foundCut; i++) &#123;</span><br><span class="line">      <span class="comment">// Semi-randomize the search order</span></span><br><span class="line">      <span class="comment">// <span class="doctag">TODO:</span> Does this do the same as in C++?</span></span><br><span class="line">      <span class="comment">// eslint-disable-next-line no-bitwise</span></span><br><span class="line">      <span class="keyword">let</span> j = (i &gt;&gt; <span class="number">1</span>) + (i &amp; <span class="number">1</span>) * ((innerSize + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">      <span class="comment">// Start at the best first point</span></span><br><span class="line">      j = (j + verts[cutId]) % innerSize;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> kk = <span class="number">0</span>; kk &lt; outerPoly.<span class="property">length</span>; kk++) &#123;</span><br><span class="line">        <span class="keyword">const</span> q = <span class="title function_">vtkCCSCutQuality</span>(outerPoly, innerPoly, kk, j, points);</span><br><span class="line">        cutlist[kk] = [q, kk];</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      cutlist.<span class="title function_">sort</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a[<span class="number">0</span>] - b[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> lid = <span class="number">0</span>; lid &lt; cutlist.<span class="property">length</span>; lid++) &#123;</span><br><span class="line">        <span class="keyword">const</span> k = cutlist[lid][<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If this is the second cut, do extra checks</span></span><br><span class="line">        <span class="keyword">if</span> (cutId &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="comment">// Make sure cuts don&#x27;t share an endpoint</span></span><br><span class="line">          <span class="keyword">if</span> (j === cuts[<span class="number">0</span>][<span class="number">1</span>] || k === cuts[<span class="number">0</span>][<span class="number">0</span>]) &#123;</span><br><span class="line">            <span class="comment">// eslint-disable-next-line no-continue</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// Make sure cuts don&#x27;t intersect</span></span><br><span class="line">          <span class="keyword">const</span> p1 = [];</span><br><span class="line">          <span class="keyword">const</span> p2 = [];</span><br><span class="line">          points.<span class="title function_">getPoint</span>(outerPoly[cuts[<span class="number">0</span>][<span class="number">0</span>]], p1);</span><br><span class="line">          points.<span class="title function_">getPoint</span>(innerPoly[cuts[<span class="number">0</span>][<span class="number">1</span>]], p2);</span><br><span class="line"></span><br><span class="line">          <span class="keyword">const</span> q1 = [];</span><br><span class="line">          <span class="keyword">const</span> q2 = [];</span><br><span class="line">          points.<span class="title function_">getPoint</span>(outerPoly[k], q1);</span><br><span class="line">          points.<span class="title function_">getPoint</span>(innerPoly[j], q2);</span><br><span class="line"></span><br><span class="line">          <span class="keyword">let</span> u;</span><br><span class="line">          <span class="keyword">let</span> v;</span><br><span class="line">          <span class="keyword">if</span> (</span><br><span class="line">            vtkLine.<span class="title function_">intersection</span>(p1, p2, q1, q2, u, v) ===</span><br><span class="line">            vtkLine.<span class="property">IntersectionState</span>.<span class="property">YES_INTERSECTION</span></span><br><span class="line">          ) &#123;</span><br><span class="line">            <span class="comment">// eslint-disable-next-line no-continue</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// This check is done for both cuts</span></span><br><span class="line">        <span class="keyword">if</span> (</span><br><span class="line">          <span class="title function_">vtkCCSCheckCut</span>(</span><br><span class="line">            polys,</span><br><span class="line">            points,</span><br><span class="line">            normal,</span><br><span class="line">            polyGroup,</span><br><span class="line">            outerPolyId,</span><br><span class="line">            innerPolyId,</span><br><span class="line">            k,</span><br><span class="line">            j</span><br><span class="line">          )</span><br><span class="line">        ) &#123;</span><br><span class="line">          cuts[cutId][<span class="number">0</span>] = k;</span><br><span class="line">          cuts[cutId][<span class="number">1</span>] = j;</span><br><span class="line">          foundCut = <span class="literal">true</span>;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!foundCut) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ---------------------------------------------------</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Helper for vtkCCSCutHoleyPolys.  Change a polygon and a hole</span></span><br><span class="line"><span class="comment"> * into two separate polygons by making two cuts between them.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Array[]</span>&#125; <span class="variable">polys</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Array</span>&#125; <span class="variable">polyEdges</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Number</span>&#125; <span class="variable">outerPolyId</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Number</span>&#125; <span class="variable">innerPolyId</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">vtkPoints</span>&#125; <span class="variable">points</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Array[]</span>&#125; <span class="variable">cuts</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">vtkCCSMakeCuts</span>(<span class="params"></span></span><br><span class="line"><span class="params">  polys,</span></span><br><span class="line"><span class="params">  polyEdges,</span></span><br><span class="line"><span class="params">  outerPolyId,</span></span><br><span class="line"><span class="params">  innerPolyId,</span></span><br><span class="line"><span class="params">  points,</span></span><br><span class="line"><span class="params">  cuts</span></span><br><span class="line"><span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> q = [];</span><br><span class="line">  <span class="keyword">const</span> r = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> bb = <span class="number">0</span>; bb &lt; <span class="number">2</span>; bb++) &#123;</span><br><span class="line">    <span class="keyword">const</span> ptId1 = polys[outerPolyId][cuts[bb][<span class="number">0</span>]];</span><br><span class="line">    <span class="keyword">const</span> ptId2 = polys[innerPolyId][cuts[bb][<span class="number">1</span>]];</span><br><span class="line">    points.<span class="title function_">getPoint</span>(ptId1, q);</span><br><span class="line">    points.<span class="title function_">getPoint</span>(ptId2, r);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> outerPoly = polys[outerPolyId];</span><br><span class="line">  <span class="keyword">const</span> innerPoly = polys[innerPolyId];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> outerEdges = polyEdges[outerPolyId];</span><br><span class="line">  <span class="keyword">const</span> innerEdges = polyEdges[innerPolyId];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Generate new polys from the cuts</span></span><br><span class="line">  <span class="keyword">const</span> n = outerPoly.<span class="property">length</span>;</span><br><span class="line">  <span class="keyword">const</span> m = innerPoly.<span class="property">length</span>;</span><br><span class="line">  <span class="keyword">let</span> idx;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Generate poly1</span></span><br><span class="line">  <span class="keyword">const</span> n1 = n * (cuts[<span class="number">1</span>][<span class="number">0</span>] &lt; cuts[<span class="number">0</span>][<span class="number">0</span>]) + cuts[<span class="number">1</span>][<span class="number">0</span>] - cuts[<span class="number">0</span>][<span class="number">0</span>] + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">const</span> n2 = n1 + m * (cuts[<span class="number">0</span>][<span class="number">1</span>] &lt; cuts[<span class="number">1</span>][<span class="number">1</span>]) + cuts[<span class="number">0</span>][<span class="number">1</span>] - cuts[<span class="number">1</span>][<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> poly1 = [];</span><br><span class="line">  poly1.<span class="property">length</span> = n2;</span><br><span class="line">  <span class="keyword">const</span> edges1 = <span class="keyword">new</span> <span class="title class_">Array</span>(n2);</span><br><span class="line"></span><br><span class="line">  idx = cuts[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i1 = <span class="number">0</span>; i1 &lt; n1; i1++) &#123;</span><br><span class="line">    <span class="keyword">const</span> k = idx++;</span><br><span class="line">    poly1[i1] = outerPoly[k];</span><br><span class="line">    edges1[i1] = outerEdges[k];</span><br><span class="line">    idx *= idx !== n;</span><br><span class="line">  &#125;</span><br><span class="line">  edges1[n1 - <span class="number">1</span>] = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  idx = cuts[<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i2 = n1; i2 &lt; n2; i2++) &#123;</span><br><span class="line">    <span class="keyword">const</span> k = idx++;</span><br><span class="line">    poly1[i2] = innerPoly[k];</span><br><span class="line">    edges1[i2] = innerEdges[k];</span><br><span class="line">    idx *= idx !== m;</span><br><span class="line">  &#125;</span><br><span class="line">  edges1[n2 - <span class="number">1</span>] = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Generate poly2</span></span><br><span class="line">  <span class="keyword">const</span> m1 = n * (cuts[<span class="number">0</span>][<span class="number">0</span>] &lt; cuts[<span class="number">1</span>][<span class="number">0</span>]) + cuts[<span class="number">0</span>][<span class="number">0</span>] - cuts[<span class="number">1</span>][<span class="number">0</span>] + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">const</span> m2 = m1 + m * (cuts[<span class="number">1</span>][<span class="number">1</span>] &lt; cuts[<span class="number">0</span>][<span class="number">1</span>]) + cuts[<span class="number">1</span>][<span class="number">1</span>] - cuts[<span class="number">0</span>][<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> poly2 = [];</span><br><span class="line">  poly2.<span class="property">length</span> = m2;</span><br><span class="line">  <span class="keyword">const</span> edges2 = <span class="keyword">new</span> <span class="title class_">Array</span>(m2);</span><br><span class="line"></span><br><span class="line">  idx = cuts[<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> j1 = <span class="number">0</span>; j1 &lt; m1; j1++) &#123;</span><br><span class="line">    <span class="keyword">const</span> k = idx++;</span><br><span class="line">    poly2[j1] = outerPoly[k];</span><br><span class="line">    edges2[j1] = outerEdges[k];</span><br><span class="line">    idx *= idx !== n;</span><br><span class="line">  &#125;</span><br><span class="line">  edges2[m1 - <span class="number">1</span>] = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  idx = cuts[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> j2 = m1; j2 &lt; m2; j2++) &#123;</span><br><span class="line">    <span class="keyword">const</span> k = idx++;</span><br><span class="line">    poly2[j2] = innerPoly[k];</span><br><span class="line">    edges2[j2] = innerEdges[k];</span><br><span class="line">    idx *= idx !== m;</span><br><span class="line">  &#125;</span><br><span class="line">  edges2[m2 - <span class="number">1</span>] = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Replace outerPoly and innerPoly with these new polys</span></span><br><span class="line">  polys[outerPolyId] = poly1;</span><br><span class="line">  polys[innerPolyId] = poly2;</span><br><span class="line">  polyEdges[outerPolyId] = edges1;</span><br><span class="line">  polyEdges[innerPolyId] = edges2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ---------------------------------------------------</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * After the holes have been identified, make cuts between the</span></span><br><span class="line"><span class="comment"> * outer poly and each hole.  Make two cuts per hole.  The only</span></span><br><span class="line"><span class="comment"> * strict requirement is that the cut must not intersect any</span></span><br><span class="line"><span class="comment"> * edges, but it&#x27;s best to make sure that no really sharp angles</span></span><br><span class="line"><span class="comment"> * are created.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Array[]</span>&#125; <span class="variable">polys</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">vtkPoints</span>&#125; <span class="variable">points</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Array[]</span>&#125; <span class="variable">polyGroups</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Array</span>&#125; <span class="variable">polyEdges</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Vector3</span>&#125; <span class="variable">normal</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns</span> &#123;<span class="type">boolean</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">vtkCCSCutHoleyPolys</span>(<span class="params"></span></span><br><span class="line"><span class="params">  polys,</span></span><br><span class="line"><span class="params">  points,</span></span><br><span class="line"><span class="params">  polyGroups,</span></span><br><span class="line"><span class="params">  polyEdges,</span></span><br><span class="line"><span class="params">  normal</span></span><br><span class="line"><span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> cutFailure = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Go through all groups and cut out the first inner poly that is</span></span><br><span class="line">  <span class="comment">// found.  Every time an inner poly is cut out, the groupId counter</span></span><br><span class="line">  <span class="comment">// is reset because cutting a poly creates a new group.</span></span><br><span class="line">  <span class="keyword">let</span> groupId = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (groupId &lt; polyGroups.<span class="property">length</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> polyGroup = polyGroups[groupId];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Only need to make a cut if the group size is greater than 1</span></span><br><span class="line">    <span class="keyword">if</span> (polyGroup.<span class="property">length</span> &gt; <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="comment">// The first member of the group is the outer poly</span></span><br><span class="line">      <span class="keyword">const</span> outerPolyId = polyGroup[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">      <span class="comment">// The second member of the group is the first inner poly</span></span><br><span class="line">      <span class="keyword">let</span> innerPolyId = polyGroup[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Sort the group by size, do largest holes first</span></span><br><span class="line">      <span class="keyword">let</span> innerBySize = <span class="keyword">new</span> <span class="title class_">Array</span>(polyGroup.<span class="property">length</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; polyGroup.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        innerBySize[i] = [polys[polyGroup[i]].<span class="property">length</span>, i];</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      innerBySize = [</span><br><span class="line">        innerBySize[<span class="number">0</span>],</span><br><span class="line">        ...innerBySize.<span class="title function_">splice</span>(<span class="number">1</span>).<span class="title function_">sort</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a[<span class="number">0</span>] - b[<span class="number">0</span>]),</span><br><span class="line">      ];</span><br><span class="line">      <span class="title function_">reverseElements</span>(innerBySize, <span class="number">1</span>, innerBySize.<span class="property">length</span> - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Need to check all inner polys in sequence, until one succeeds.</span></span><br><span class="line">      <span class="comment">// Do a quick search first, then do an exhaustive search.</span></span><br><span class="line">      <span class="keyword">let</span> madeCut = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">let</span> inner = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> exhaustive = <span class="number">0</span>; exhaustive &lt; <span class="number">2</span> &amp;&amp; !madeCut; exhaustive++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">1</span>; j &lt; polyGroup.<span class="property">length</span>; j++) &#123;</span><br><span class="line">          inner = innerBySize[j][<span class="number">1</span>];</span><br><span class="line">          innerPolyId = polyGroup[inner];</span><br><span class="line"></span><br><span class="line">          <span class="keyword">const</span> cuts = [];</span><br><span class="line">          <span class="keyword">if</span> (</span><br><span class="line">            <span class="title function_">vtkCCSFindCuts</span>(</span><br><span class="line">              polys,</span><br><span class="line">              polyGroup,</span><br><span class="line">              outerPolyId,</span><br><span class="line">              innerPolyId,</span><br><span class="line">              points,</span><br><span class="line">              normal,</span><br><span class="line">              cuts,</span><br><span class="line">              exhaustive</span><br><span class="line">            )</span><br><span class="line">          ) &#123;</span><br><span class="line">            <span class="title function_">vtkCCSMakeCuts</span>(</span><br><span class="line">              polys,</span><br><span class="line">              polyEdges,</span><br><span class="line">              outerPolyId,</span><br><span class="line">              innerPolyId,</span><br><span class="line">              points,</span><br><span class="line">              cuts</span><br><span class="line">            );</span><br><span class="line">            madeCut = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (madeCut) &#123;</span><br><span class="line">        <span class="comment">// Move successfully cut innerPolyId into its own group</span></span><br><span class="line">        polyGroup.<span class="title function_">splice</span>(inner, <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// Only add if innerPolyId hasn&#x27;t been set already.</span></span><br><span class="line">        <span class="comment">// Having the same poly occur as both polyGroup and</span></span><br><span class="line">        <span class="comment">// innerPoly would cause an infinite loop.</span></span><br><span class="line">        <span class="keyword">if</span> (polyGroups[innerPolyId].<span class="property">length</span> === <span class="number">0</span>) &#123;</span><br><span class="line">          polyGroups[innerPolyId].<span class="title function_">push</span>(innerPolyId);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Remove all failed inner polys from the group</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> k = <span class="number">1</span>; k &lt; polyGroup.<span class="property">length</span>; k++) &#123;</span><br><span class="line">          innerPolyId = polyGroup[k];</span><br><span class="line">          <span class="comment">// Only add if innerPolyId hasn&#x27;t been set already.</span></span><br><span class="line">          <span class="comment">// Having the same poly occur as both polyGroup and</span></span><br><span class="line">          <span class="comment">// innerPoly would cause an infinite loop.</span></span><br><span class="line">          <span class="keyword">if</span> (polyGroups[innerPolyId].<span class="property">length</span> === <span class="number">0</span>) &#123;</span><br><span class="line">            polyGroups[innerPolyId].<span class="title function_">push</span>(innerPolyId);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        polyGroup.<span class="property">length</span> = <span class="number">1</span>;</span><br><span class="line">        cutFailure = <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// If there are other interior polys in the group, find out whether</span></span><br><span class="line">      <span class="comment">// they are in poly1 or poly2</span></span><br><span class="line">      <span class="keyword">if</span> (polyGroup.<span class="property">length</span> &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> poly1 = polys[outerPolyId];</span><br><span class="line">        <span class="keyword">const</span> pp = <span class="keyword">new</span> <span class="title class_">Float64Array</span>(<span class="number">3</span> * poly1.<span class="property">length</span>);</span><br><span class="line">        <span class="keyword">const</span> bounds = [<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>];</span><br><span class="line">        <span class="keyword">const</span> tol2 = <span class="title function_">vtkCCSPrepareForPolyInPoly</span>(poly1, points, pp, bounds);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> nextGroupId = groupId;</span><br><span class="line">        <span class="keyword">let</span> ii = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (ii &lt; polyGroup.<span class="property">length</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span> (</span><br><span class="line">            <span class="title function_">vtkCCSPolyInPoly</span>(</span><br><span class="line">              poly1,</span><br><span class="line">              polys[polyGroup[ii]],</span><br><span class="line">              points,</span><br><span class="line">              normal,</span><br><span class="line">              pp,</span><br><span class="line">              bounds,</span><br><span class="line">              tol2</span><br><span class="line">            )</span><br><span class="line">          ) &#123;</span><br><span class="line">            <span class="comment">// Keep this poly in polyGroup</span></span><br><span class="line">            ii++;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Move this poly to poly2 group</span></span><br><span class="line">            polyGroups[innerPolyId].<span class="title function_">push</span>(polyGroup[ii]);</span><br><span class="line">            polyGroup.<span class="title function_">splice</span>(ii, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Reduce the groupId to ensure that this new group will get cut</span></span><br><span class="line">            <span class="keyword">if</span> (innerPolyId &lt; nextGroupId) &#123;</span><br><span class="line">              nextGroupId = innerPolyId;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Set the groupId for the next iteration</span></span><br><span class="line">        groupId = nextGroupId;</span><br><span class="line">        <span class="comment">// eslint-disable-next-line no-continue</span></span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Increment to the next group</span></span><br><span class="line">    groupId++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> !cutFailure;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><figcaption><span>index.d.ts</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; vtkAlgorithm, vtkObject &#125; <span class="keyword">from</span> <span class="string">&quot;../../../interfaces&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Nullable</span>, <span class="title class_">TypedArray</span>, <span class="title class_">Vector3</span> &#125; <span class="keyword">from</span> <span class="string">&quot;../../../types&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> vtkCellArray <span class="keyword">from</span> <span class="string">&quot;../../../Common/Core/CellArray&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> vtkPolyData <span class="keyword">from</span> <span class="string">&quot;../../../Common/DataModel/PolyData&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> vtkPoints <span class="keyword">from</span> <span class="string">&quot;../../../Common/Core/Points&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> interface <span class="title class_">IContourTriangulatorInitialValues</span> &#123;</span><br><span class="line">	triangulatePolys?: boolean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type vtkContourTriangulatorBase = vtkObject &amp; vtkAlgorithm;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> interface vtkContourTriangulator <span class="keyword">extends</span> vtkContourTriangulatorBase &#123;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> &#123;<span class="type">any</span>&#125; <span class="variable">inData</span></span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> &#123;<span class="type">any</span>&#125; <span class="variable">outData</span></span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="title function_">requestData</span>(<span class="attr">inData</span>: any, <span class="attr">outData</span>: any): <span class="keyword">void</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Sets the behavior of the filter regarding polys.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> &#123;<span class="type">boolean</span>&#125; triangulate whether the filter should triangulate polys</span></span><br><span class="line"><span class="comment">	 * or leave them untouched. True by default</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> &#123;<span class="type">boolean</span>&#125; true if it changes</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="title function_">setTriangulatePolys</span>(<span class="attr">triangulate</span>: boolean): boolean;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Returns the behavior of the filter regarding polys.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> &#123;<span class="type">boolean</span>&#125; True if the filter triangulates polys, false otherwise.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="title function_">getTriangulatePolys</span>(): boolean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ----------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">// Static API</span></span><br><span class="line"><span class="comment">// ----------------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This is a complex subroutine that takes a collection of lines that</span></span><br><span class="line"><span class="comment"> * were formed by cutting a polydata with a plane, and generates</span></span><br><span class="line"><span class="comment"> * a face that has those lines as its edges.  The lines must form one</span></span><br><span class="line"><span class="comment"> * or more closed contours, but they need not be sorted.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Only &quot;numLine&quot; lines starting from &quot;firstLine&quot; are used to create new</span></span><br><span class="line"><span class="comment"> * polygons, and the new polygons are appended to &quot;polys&quot;. The normal of</span></span><br><span class="line"><span class="comment"> * the cut plane must be provided so that polys will be correctly oriented.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Given some closed contour lines, create a triangle mesh that fills</span></span><br><span class="line"><span class="comment"> * those lines. The input lines do not have to be in tail-to-tip order.</span></span><br><span class="line"><span class="comment"> * Only numLines starting from firstLine will be used. Note that holes</span></span><br><span class="line"><span class="comment"> * can be indicated by contour loops whose normals are in the opposite</span></span><br><span class="line"><span class="comment"> * direction to the provided normal.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">vtkPolyData</span>&#125; <span class="variable">polyData</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Number</span>&#125; <span class="variable">firstLine</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Number</span>&#125; <span class="variable">numLines</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">vtkCellArray</span>&#125; <span class="variable">polys</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Nullable&lt;Vector3&gt;</span>&#125; normal If null, the function will compute</span></span><br><span class="line"><span class="comment"> * the normal of the polys.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Boolean</span>&#125; [triangulatePolys] (default: true) If set to true</span></span><br><span class="line"><span class="comment"> * the resulting polygons will be triangulated, otherwise the polygons</span></span><br><span class="line"><span class="comment"> * themselves will be added to the output.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Boolean</span>&#125; [diagnoseOnTriangulationError] (default: false)</span></span><br><span class="line"><span class="comment"> * If this option is set to true and there was a triangulation error</span></span><br><span class="line"><span class="comment"> * this will add the polys as outlines to the output.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns</span> &#123;<span class="type">Boolean</span>&#125; Returns true if triangulation was successful,</span></span><br><span class="line"><span class="comment"> * false otherwise.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">triangulateContours</span>(<span class="params"></span></span><br><span class="line"><span class="params">	polyData: vtkPolyData,</span></span><br><span class="line"><span class="params">	firstLine: number,</span></span><br><span class="line"><span class="params">	numLines: number,</span></span><br><span class="line"><span class="params">	polys: vtkCellArray,</span></span><br><span class="line"><span class="params">	normal: Nullable&lt;Vector3&gt;,</span></span><br><span class="line"><span class="params">	triangulatePolys?: boolean,</span></span><br><span class="line"><span class="params">	diagnoseOnTriangulationError?: boolean</span></span><br><span class="line"><span class="params"></span>): boolean;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A robust method for triangulating a polygon. It cleans up the polygon</span></span><br><span class="line"><span class="comment"> * and then applies the ear-cut triangulation. A zero return value</span></span><br><span class="line"><span class="comment"> * indicates that triangulation failed.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Array&lt;Number&gt;|TypedArray</span>&#125; polygon Array of point indices defining the polygon</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">vtkPoints</span>&#125; points The point coordinates of the polygon</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">vtkCellArray</span>&#125; triangles The cell array that is going to be</span></span><br><span class="line"><span class="comment"> * filled with the triangulation</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns</span> &#123;<span class="type">Boolean</span>&#125; Returns true if triangulation was successful,</span></span><br><span class="line"><span class="comment"> * false otherwise.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">triangulatePolygon</span>(<span class="params"></span></span><br><span class="line"><span class="params">	polygon: <span class="built_in">Array</span>&lt;number&gt; | TypedArray,</span></span><br><span class="line"><span class="params">	points: vtkPoints,</span></span><br><span class="line"><span class="params">	triangles: vtkCellArray</span></span><br><span class="line"><span class="params"></span>): boolean;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Method use to decorate a given object (publicAPI+model) with vtkContourTriangulator characteristics.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> publicAPI object on which methods will be bounds (public)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> model object on which data structure will be bounds (protected)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">IContourTriangulatorInitialValues</span>&#125; [initialValues] (default: &#123;&#125;)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">extend</span>(<span class="params"></span></span><br><span class="line"><span class="params">	publicAPI: object,</span></span><br><span class="line"><span class="params">	model: object,</span></span><br><span class="line"><span class="params">	initialValues?: IContourTriangulatorInitialValues</span></span><br><span class="line"><span class="params"></span>): <span class="keyword">void</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ----------------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Method use to create a new instance of vtkContourTriangulator</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">IContourTriangulatorInitialValues</span>&#125; [initialValues] for pre-setting some of its content</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">newInstance</span>(<span class="params"></span></span><br><span class="line"><span class="params">	initialValues?: IContourTriangulatorInitialValues</span></span><br><span class="line"><span class="params"></span>): vtkContourTriangulator;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * vtkContourTriangulator</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> declare <span class="keyword">const</span> <span class="attr">vtkContourTriangulator</span>: &#123;</span><br><span class="line">	<span class="attr">newInstance</span>: <span class="keyword">typeof</span> newInstance;</span><br><span class="line">	<span class="attr">extend</span>: <span class="keyword">typeof</span> extend;</span><br><span class="line">	<span class="comment">// static</span></span><br><span class="line">	<span class="attr">triangulateContours</span>: <span class="keyword">typeof</span> triangulateContours;</span><br><span class="line">	<span class="attr">triangulatePolygon</span>: <span class="keyword">typeof</span> triangulatePolygon;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> vtkContourTriangulator;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><figcaption><span>index.js</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> macro <span class="keyword">from</span> <span class="string">&#x27;vtk.js/Sources/macros&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> vtkCellArray <span class="keyword">from</span> <span class="string">&#x27;vtk.js/Sources/Common/Core/CellArray&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> vtkPolygon <span class="keyword">from</span> <span class="string">&#x27;vtk.js/Sources/Common/DataModel/Polygon&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> vtkPolyData <span class="keyword">from</span> <span class="string">&#x27;vtk.js/Sources/Common/DataModel/PolyData&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">VtkDataTypes</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;vtk.js/Sources/Common/Core/DataArray/Constants&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  vtkCCSCutHoleyPolys,</span><br><span class="line">  vtkCCSFindTrueEdges,</span><br><span class="line">  vtkCCSJoinLooseEnds,</span><br><span class="line">  vtkCCSMakeHoleyPolys,</span><br><span class="line">  vtkCCSMakePolysFromLines,</span><br><span class="line">  vtkCCSSplitAtPinchPoints,</span><br><span class="line">  vtkCCSTriangulate,</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">&#x27;./helper&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; vtkErrorMacro &#125; = macro;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">TRIANGULATION_ERROR_DISPLAY</span> = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">DIAGNOSE_ON_TRIANGULATION_ERROR</span> = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//------------------------------------------------------------------------------</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">triangulateContours</span>(<span class="params"></span></span><br><span class="line"><span class="params">  polyData,</span></span><br><span class="line"><span class="params">  firstLine,</span></span><br><span class="line"><span class="params">  numLines,</span></span><br><span class="line"><span class="params">  polys,</span></span><br><span class="line"><span class="params">  normal,</span></span><br><span class="line"><span class="params">  triangulatePolys = <span class="literal">true</span></span></span><br><span class="line"><span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> triangulationFailure = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If no cut lines were generated, there&#x27;s nothing to do</span></span><br><span class="line">  <span class="keyword">if</span> (numLines &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> points = polyData.<span class="title function_">getPoints</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Join all the new lines into connected groups, i.e. polygons.</span></span><br><span class="line">  <span class="comment">// If we are lucky these will be simple, convex polygons. But</span></span><br><span class="line">  <span class="comment">// we can&#x27;t count on that.</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> newPolys = [];</span><br><span class="line">  <span class="keyword">const</span> incompletePolys = [];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> oriented = normal?.<span class="property">length</span> &lt; <span class="number">3</span>;</span><br><span class="line">  <span class="title function_">vtkCCSMakePolysFromLines</span>(</span><br><span class="line">    polyData,</span><br><span class="line">    firstLine,</span><br><span class="line">    firstLine + numLines,</span><br><span class="line">    oriented,</span><br><span class="line">    newPolys,</span><br><span class="line">    incompletePolys</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="comment">// if no normal specified, then compute one from largest contour</span></span><br><span class="line">  <span class="keyword">let</span> computedNormal = normal;</span><br><span class="line">  <span class="keyword">if</span> (!oriented) &#123;</span><br><span class="line">    computedNormal = [<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">let</span> maxnorm = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">const</span> n = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; newPolys.<span class="property">length</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">const</span> norm = vtkPolygon.<span class="title function_">getNormal</span>(newPolys[i], points, n);</span><br><span class="line">      <span class="keyword">if</span> (norm &gt; maxnorm) &#123;</span><br><span class="line">        maxnorm = norm;</span><br><span class="line">        computedNormal[<span class="number">0</span>] = n[<span class="number">0</span>];</span><br><span class="line">        computedNormal[<span class="number">1</span>] = n[<span class="number">1</span>];</span><br><span class="line">        computedNormal[<span class="number">2</span>] = n[<span class="number">2</span>];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Join any loose ends. If the input was a closed surface then there</span></span><br><span class="line">  <span class="comment">// will not be any loose ends, so this is provided as a service to users</span></span><br><span class="line">  <span class="comment">// who want to clip a non-closed surface.</span></span><br><span class="line">  <span class="title function_">vtkCCSJoinLooseEnds</span>(newPolys, incompletePolys, points, computedNormal);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Some points might be in the middle of straight line segments.</span></span><br><span class="line">  <span class="comment">// These points can be removed without changing the shape of the</span></span><br><span class="line">  <span class="comment">// polys, and removing them makes triangulation more stable.</span></span><br><span class="line">  <span class="comment">// Unfortunately removing these points also means that the polys</span></span><br><span class="line">  <span class="comment">// will no longer form a watertight cap over the cut.</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> polyEdges = [];</span><br><span class="line">  <span class="keyword">const</span> originalEdges = [];</span><br><span class="line">  <span class="title function_">vtkCCSFindTrueEdges</span>(newPolys, points, polyEdges, originalEdges);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Next we have to check for polygons with holes, i.e. polygons that</span></span><br><span class="line">  <span class="comment">// have other polygons inside. Each polygon is &quot;grouped&quot; with the</span></span><br><span class="line">  <span class="comment">// polygons that make up its holes.</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Initialize each group to hold just one polygon.</span></span><br><span class="line">  <span class="keyword">const</span> numNewPolys = newPolys.<span class="property">length</span>;</span><br><span class="line">  <span class="keyword">const</span> polyGroups = <span class="keyword">new</span> <span class="title class_">Array</span>(numNewPolys);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; numNewPolys; i++) &#123;</span><br><span class="line">    polyGroups[i] = [i];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Find out which polys are holes in larger polys. Create a group</span></span><br><span class="line">  <span class="comment">// for each poly where the first member of the group is the larger</span></span><br><span class="line">  <span class="comment">// poly, and all other members are the holes. The number of polyGroups</span></span><br><span class="line">  <span class="comment">// will be the same as the number of polys, and any polys that are</span></span><br><span class="line">  <span class="comment">// holes will have a matching empty group.</span></span><br><span class="line"></span><br><span class="line">  <span class="title function_">vtkCCSMakeHoleyPolys</span>(</span><br><span class="line">    newPolys,</span><br><span class="line">    points,</span><br><span class="line">    polyGroups,</span><br><span class="line">    polyEdges,</span><br><span class="line">    originalEdges,</span><br><span class="line">    computedNormal,</span><br><span class="line">    oriented</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Make cuts to create simple polygons out of the holey polys.</span></span><br><span class="line">  <span class="comment">// After this is done, each polyGroup will have exactly 1 polygon,</span></span><br><span class="line">  <span class="comment">// and no polys will be holes. This is currently the most computationally</span></span><br><span class="line">  <span class="comment">// expensive part of the process.</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    !<span class="title function_">vtkCCSCutHoleyPolys</span>(</span><br><span class="line">      newPolys,</span><br><span class="line">      points,</span><br><span class="line">      polyGroups,</span><br><span class="line">      polyEdges,</span><br><span class="line">      computedNormal</span><br><span class="line">    )</span><br><span class="line">  ) &#123;</span><br><span class="line">    triangulationFailure = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Some polys might be self-intersecting. Split the polys at each intersection point.</span></span><br><span class="line">  <span class="title function_">vtkCCSSplitAtPinchPoints</span>(</span><br><span class="line">    newPolys,</span><br><span class="line">    points,</span><br><span class="line">    polyGroups,</span><br><span class="line">    polyEdges,</span><br><span class="line">    computedNormal,</span><br><span class="line">    oriented</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ------ Triangulation code ------</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Go through all polys and triangulate them</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> polyId = <span class="number">0</span>; polyId &lt; polyGroups.<span class="property">length</span>; polyId++) &#123;</span><br><span class="line">    <span class="comment">// If group is empty, then poly was a hole without a containing poly</span></span><br><span class="line">    <span class="keyword">if</span> (polyGroups[polyId].<span class="property">length</span> === <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// eslint-disable-next-line no-continue</span></span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!triangulatePolys) &#123;</span><br><span class="line">      polys.<span class="title function_">insertNextCell</span>(originalEdges.<span class="title function_">slice</span>(<span class="number">1</span>, originalEdges.<span class="property">length</span>));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (</span><br><span class="line">      !<span class="title function_">vtkCCSTriangulate</span>(</span><br><span class="line">        newPolys[polyId],</span><br><span class="line">        points,</span><br><span class="line">        polyEdges[polyId],</span><br><span class="line">        originalEdges,</span><br><span class="line">        polys,</span><br><span class="line">        computedNormal</span><br><span class="line">      )</span><br><span class="line">    ) &#123;</span><br><span class="line">      triangulationFailure = <span class="literal">false</span>;</span><br><span class="line">      <span class="comment">// Diagnostic code: show the polys as outlines</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="variable constant_">DIAGNOSE_ON_TRIANGULATION_ERROR</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> lines = polyData.<span class="title function_">getLines</span>();</span><br><span class="line">        <span class="keyword">const</span> poly = newPolys[polyId];</span><br><span class="line">        lines.<span class="title function_">insertNextCell</span>([poly.<span class="property">length</span> + <span class="number">1</span>, ...poly, poly[<span class="number">0</span>]]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> !triangulationFailure;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ---------------------------------------------------</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">triangulatePolygon</span>(<span class="params">polygon, points, triangles</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> poly = [...polygon];</span><br><span class="line">  <span class="keyword">const</span> polys = [poly];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> originalEdges = [];</span><br><span class="line">  <span class="keyword">const</span> polyEdges = [];</span><br><span class="line">  <span class="title function_">vtkCCSFindTrueEdges</span>(polys, points, polyEdges, originalEdges);</span><br><span class="line">  <span class="keyword">const</span> edges = polyEdges[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> success = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">const</span> normal = [];</span><br><span class="line">  <span class="keyword">const</span> norm = vtkPolygon.<span class="title function_">getNormal</span>(poly, points, normal);</span><br><span class="line">  <span class="keyword">if</span> (norm !== <span class="number">0</span>) &#123;</span><br><span class="line">    success = <span class="title function_">vtkCCSTriangulate</span>(</span><br><span class="line">      poly,</span><br><span class="line">      points,</span><br><span class="line">      edges,</span><br><span class="line">      originalEdges,</span><br><span class="line">      triangles,</span><br><span class="line">      normal</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> success;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="variable constant_">STATIC</span> = &#123; triangulateContours, triangulatePolygon &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">vtkContourTriangulator</span>(<span class="params">publicAPI, model</span>) &#123;</span><br><span class="line">  <span class="comment">// Set our className</span></span><br><span class="line">  model.<span class="property">classHierarchy</span>.<span class="title function_">push</span>(<span class="string">&#x27;vtkContourTriangulator&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  publicAPI.<span class="property">requestData</span> = <span class="function">(<span class="params">inData, outData</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// implement requestData</span></span><br><span class="line">    <span class="keyword">const</span> input = inData[<span class="number">0</span>];</span><br><span class="line">    <span class="comment">// <span class="doctag">FIXME:</span> do not instantiate a new polydata each time the filter is executed.</span></span><br><span class="line">    <span class="keyword">const</span> output = vtkPolyData.<span class="title function_">newInstance</span>();</span><br><span class="line">    outData[<span class="number">0</span>] = output;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!input) &#123;</span><br><span class="line">      <span class="title function_">vtkErrorMacro</span>(<span class="string">&#x27;Invalid or missing input&#x27;</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> triangulationError = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> lines = input.<span class="title function_">getLines</span>();</span><br><span class="line">    <span class="keyword">if</span> (lines == <span class="literal">null</span> || lines.<span class="title function_">getNumberOfCells</span>() === <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    input.<span class="title function_">buildCells</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> polysArray = vtkCellArray.<span class="title function_">newInstance</span>(&#123;</span><br><span class="line">      <span class="attr">dataType</span>: <span class="title class_">VtkDataTypes</span>.<span class="property">DOUBLE</span>,</span><br><span class="line">      <span class="attr">empty</span>: <span class="literal">true</span>,</span><br><span class="line">    &#125;);</span><br><span class="line">    output.<span class="title function_">setPolys</span>(polysArray);</span><br><span class="line">    output.<span class="title function_">setPoints</span>(input.<span class="title function_">getPoints</span>());</span><br><span class="line">    output.<span class="title function_">getPointData</span>().<span class="title function_">passData</span>(input.<span class="title function_">getPointData</span>());</span><br><span class="line"></span><br><span class="line">    triangulationError = !<span class="title function_">triangulateContours</span>(</span><br><span class="line">      input,</span><br><span class="line">      input.<span class="title function_">getNumberOfVerts</span>(),</span><br><span class="line">      lines.<span class="title function_">getNumberOfCells</span>(),</span><br><span class="line">      polysArray,</span><br><span class="line">      <span class="literal">null</span>,</span><br><span class="line">      model.<span class="property">triangulatePolys</span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (triangulationError &amp;&amp; <span class="variable constant_">TRIANGULATION_ERROR_DISPLAY</span>) &#123;</span><br><span class="line">      <span class="title function_">vtkErrorMacro</span>(<span class="string">&#x27;Triangulation failed, output might have holes.&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ----------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">// Object factory</span></span><br><span class="line"><span class="comment">// ----------------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">DEFAULT_VALUES</span> = &#123;</span><br><span class="line">  <span class="attr">triangulatePolys</span>: <span class="literal">true</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ----------------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">extend</span>(<span class="params">publicAPI, model, initialValues = &#123;&#125;</span>) &#123;</span><br><span class="line">  <span class="title class_">Object</span>.<span class="title function_">assign</span>(model, <span class="variable constant_">DEFAULT_VALUES</span>, initialValues);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Make this a VTK object</span></span><br><span class="line">  macro.<span class="title function_">obj</span>(publicAPI, model);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Also make it an algorithm with one input and one output</span></span><br><span class="line">  macro.<span class="title function_">algo</span>(publicAPI, model, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  macro.<span class="title function_">setGet</span>(publicAPI, model, [<span class="string">&#x27;triangulatePolys&#x27;</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Object specific methods</span></span><br><span class="line">  <span class="title function_">vtkContourTriangulator</span>(publicAPI, model);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ----------------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> newInstance = macro.<span class="title function_">newInstance</span>(extend, <span class="string">&#x27;vtkContourTriangulator&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ----------------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123; newInstance, extend, ...<span class="variable constant_">STATIC</span> &#125;;</span><br></pre></td></tr></table></figure>

              </div>
              <footer class="article-footer">
                <time class="article-footer-updated" datetime="2024-02-28T16:05:51.965Z" itemprop="dateModified">Last updated: 2024-02-28</time>
                <a href="Filters_General_ContourLoopExtraction.html" class="article-footer-prev" title="ContourLoopExtraction"><i class="fa fa-chevron-left"></i><span>Prev</span></a><a href="Filters_General_ImageCropFilter.html" class="article-footer-next" title="ImageCropFilter"><span>Next</span><i class="fa fa-chevron-right"></i></a>
              </footer>
              
            </div>
          </div>
          <aside id="article-toc" role="navigation">
            <div id="article-toc-inner">
              <strong class="sidebar-title">Contents</strong>
              <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Introduction"><span class="toc-text">Introduction</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Methods"><span class="toc-text">Methods</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#extend"><span class="toc-text">extend</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#getTriangulatePolys"><span class="toc-text">getTriangulatePolys</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#newInstance"><span class="toc-text">newInstance</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#requestData"><span class="toc-text">requestData</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#setTriangulatePolys"><span class="toc-text">setTriangulatePolys</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#triangulateContours"><span class="toc-text">triangulateContours</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Returns"><span class="toc-text">Returns</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#triangulatePolygon"><span class="toc-text">triangulatePolygon</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Returns-1"><span class="toc-text">Returns</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Source"><span class="toc-text">Source</span></a>
              <a href="#" id="article-toc-top">Back to Top</a>
            </div>
          </aside>
        </div>
      </article>
      <aside id="sidebar" role="navigation">
  <div class="inner"><strong class="sidebar-title">Common/Core</strong><a href="Common_Core_Base64.html" class="sidebar-link">Base64</a><a href="Common_Core_CellArray.html" class="sidebar-link">CellArray</a><a href="Common_Core_ClassHierarchy.html" class="sidebar-link">ClassHierarchy</a><a href="Common_Core_DataArray.html" class="sidebar-link">DataArray</a><a href="Common_Core_Endian.html" class="sidebar-link">Endian</a><a href="Common_Core_HalfFloat.html" class="sidebar-link">HalfFloat</a><a href="Common_Core_ImageHelper.html" class="sidebar-link">ImageHelper</a><a href="Common_Core_LookupTable.html" class="sidebar-link">LookupTable</a><a href="Common_Core_Math.html" class="sidebar-link">Math</a><a href="Common_Core_MatrixBuilder.html" class="sidebar-link">MatrixBuilder</a><a href="Common_Core_Points.html" class="sidebar-link">Points</a><a href="Common_Core_PriorityQueue.html" class="sidebar-link">PriorityQueue</a><a href="Common_Core_ProgressHandler.html" class="sidebar-link">ProgressHandler</a><a href="Common_Core_ScalarsToColors.html" class="sidebar-link">ScalarsToColors</a><a href="Common_Core_StringArray.html" class="sidebar-link">StringArray</a><a href="Common_Core_URLExtract.html" class="sidebar-link">URLExtract</a><a href="Common_Core_VariantArray.html" class="sidebar-link">VariantArray</a><strong class="sidebar-title">Common/DataModel</strong><a href="Common_DataModel_AbstractPointLocator.html" class="sidebar-link">AbstractPointLocator</a><a href="Common_DataModel_BoundingBox.html" class="sidebar-link">BoundingBox</a><a href="Common_DataModel_Box.html" class="sidebar-link">Box</a><a href="Common_DataModel_CardinalSpline1D.html" class="sidebar-link">CardinalSpline1D</a><a href="Common_DataModel_Cell.html" class="sidebar-link">Cell</a><a href="Common_DataModel_CellLinks.html" class="sidebar-link">CellLinks</a><a href="Common_DataModel_CellTypes.html" class="sidebar-link">CellTypes</a><a href="Common_DataModel_Collection.html" class="sidebar-link">Collection</a><a href="Common_DataModel_Cone.html" class="sidebar-link">Cone</a><a href="Common_DataModel_Cylinder.html" class="sidebar-link">Cylinder</a><a href="Common_DataModel_DataSet.html" class="sidebar-link">DataSet</a><a href="Common_DataModel_DataSetAttributes.html" class="sidebar-link">DataSetAttributes</a><a href="Common_DataModel_EdgeLocator.html" class="sidebar-link">EdgeLocator</a><a href="Common_DataModel_ITKHelper.html" class="sidebar-link">ITKHelper</a><a href="Common_DataModel_ImageData.html" class="sidebar-link">ImageData</a><a href="Common_DataModel_ImplicitBoolean.html" class="sidebar-link">ImplicitBoolean</a><a href="Common_DataModel_IncrementalOctreeNode.html" class="sidebar-link">IncrementalOctreeNode</a><a href="Common_DataModel_IncrementalOctreePointLocator.html" class="sidebar-link">IncrementalOctreePointLocator</a><a href="Common_DataModel_KochanekSpline1D.html" class="sidebar-link">KochanekSpline1D</a><a href="Common_DataModel_Line.html" class="sidebar-link">Line</a><a href="Common_DataModel_Locator.html" class="sidebar-link">Locator</a><a href="Common_DataModel_Molecule.html" class="sidebar-link">Molecule</a><a href="Common_DataModel_PiecewiseFunction.html" class="sidebar-link">PiecewiseFunction</a><a href="Common_DataModel_Plane.html" class="sidebar-link">Plane</a><a href="Common_DataModel_PointSet.html" class="sidebar-link">PointSet</a><a href="Common_DataModel_PolyData.html" class="sidebar-link">PolyData</a><a href="Common_DataModel_PolyLine.html" class="sidebar-link">PolyLine</a><a href="Common_DataModel_Polygon.html" class="sidebar-link">Polygon</a><a href="Common_DataModel_Quad.html" class="sidebar-link">Quad</a><a href="Common_DataModel_SelectionNode.html" class="sidebar-link">SelectionNode</a><a href="Common_DataModel_Sphere.html" class="sidebar-link">Sphere</a><a href="Common_DataModel_Spline1D.html" class="sidebar-link">Spline1D</a><a href="Common_DataModel_Spline3D.html" class="sidebar-link">Spline3D</a><a href="Common_DataModel_StructuredData.html" class="sidebar-link">StructuredData</a><a href="Common_DataModel_Triangle.html" class="sidebar-link">Triangle</a><strong class="sidebar-title">Common/System</strong><a href="Common_System_MobileVR.html" class="sidebar-link">MobileVR</a><a href="Common_System_TimerLog.html" class="sidebar-link">TimerLog</a><strong class="sidebar-title">Common/Transform</strong><a href="Common_Transform_LandmarkTransform.html" class="sidebar-link">LandmarkTransform</a><a href="Common_Transform_Transform.html" class="sidebar-link">Transform</a><strong class="sidebar-title">Filters/Core</strong><a href="Filters_Core_Cutter.html" class="sidebar-link">Cutter</a><a href="Filters_Core_PolyDataNormals.html" class="sidebar-link">PolyDataNormals</a><strong class="sidebar-title">Filters/Cornerstone</strong><a href="Filters_Cornerstone_ImageDataToCornerstoneImage.html" class="sidebar-link">ImageDataToCornerstoneImage</a><strong class="sidebar-title">Filters/General</strong><a href="Filters_General_AppendPolyData.html" class="sidebar-link">AppendPolyData</a><a href="Filters_General_Calculator.html" class="sidebar-link">Calculator</a><a href="Filters_General_ClipClosedSurface.html" class="sidebar-link">ClipClosedSurface</a><a href="Filters_General_ClosedPolyLineToSurfaceFilter.html" class="sidebar-link">ClosedPolyLineToSurfaceFilter</a><a href="Filters_General_ContourLoopExtraction.html" class="sidebar-link">ContourLoopExtraction</a><a href="Filters_General_ContourTriangulator.html" class="sidebar-link current">ContourTriangulator</a><a href="Filters_General_ImageCropFilter.html" class="sidebar-link">ImageCropFilter</a><a href="Filters_General_ImageDataOutlineFilter.html" class="sidebar-link">ImageDataOutlineFilter</a><a href="Filters_General_ImageMarchingCubes.html" class="sidebar-link">ImageMarchingCubes</a><a href="Filters_General_ImageMarchingSquares.html" class="sidebar-link">ImageMarchingSquares</a><a href="Filters_General_ImageOutlineFilter.html" class="sidebar-link">ImageOutlineFilter</a><a href="Filters_General_ImageSliceFilter.html" class="sidebar-link">ImageSliceFilter</a><a href="Filters_General_ImageStreamline.html" class="sidebar-link">ImageStreamline</a><a href="Filters_General_LineFilter.html" class="sidebar-link">LineFilter</a><a href="Filters_General_MoleculeToRepresentation.html" class="sidebar-link">MoleculeToRepresentation</a><a href="Filters_General_OBBTree.html" class="sidebar-link">OBBTree</a><a href="Filters_General_OutlineFilter.html" class="sidebar-link">OutlineFilter</a><a href="Filters_General_PaintFilter.html" class="sidebar-link">PaintFilter</a><a href="Filters_General_ScalarToRGBA.html" class="sidebar-link">ScalarToRGBA</a><a href="Filters_General_TriangleFilter.html" class="sidebar-link">TriangleFilter</a><a href="Filters_General_TubeFilter.html" class="sidebar-link">TubeFilter</a><a href="Filters_General_WarpScalar.html" class="sidebar-link">WarpScalar</a><a href="Filters_General_WindowedSincPolyDataFilter.html" class="sidebar-link">WindowedSincPolyDataFilter</a><strong class="sidebar-title">Filters/Sources</strong><a href="Filters_Sources_Arrow2DSource.html" class="sidebar-link">Arrow2DSource</a><a href="Filters_Sources_ArrowSource.html" class="sidebar-link">ArrowSource</a><a href="Filters_Sources_CircleSource.html" class="sidebar-link">CircleSource</a><a href="Filters_Sources_ConcentricCylinderSource.html" class="sidebar-link">ConcentricCylinderSource</a><a href="Filters_Sources_ConeSource.html" class="sidebar-link">ConeSource</a><a href="Filters_Sources_CubeSource.html" class="sidebar-link">CubeSource</a><a href="Filters_Sources_Cursor3D.html" class="sidebar-link">Cursor3D</a><a href="Filters_Sources_CylinderSource.html" class="sidebar-link">CylinderSource</a><a href="Filters_Sources_ImageGridSource.html" class="sidebar-link">ImageGridSource</a><a href="Filters_Sources_LineSource.html" class="sidebar-link">LineSource</a><a href="Filters_Sources_PlaneSource.html" class="sidebar-link">PlaneSource</a><a href="Filters_Sources_PointSource.html" class="sidebar-link">PointSource</a><a href="Filters_Sources_RTAnalyticSource.html" class="sidebar-link">RTAnalyticSource</a><a href="Filters_Sources_SLICSource.html" class="sidebar-link">SLICSource</a><a href="Filters_Sources_SphereSource.html" class="sidebar-link">SphereSource</a><a href="Filters_Sources_ViewFinderSource.html" class="sidebar-link">ViewFinderSource</a><strong class="sidebar-title">Filters/Texture</strong><a href="Filters_Texture_TextureMapToPlane.html" class="sidebar-link">TextureMapToPlane</a><a href="Filters_Texture_TextureMapToSphere.html" class="sidebar-link">TextureMapToSphere</a><strong class="sidebar-title">Imaging/Core</strong><a href="Imaging_Core_AbstractImageInterpolator.html" class="sidebar-link">AbstractImageInterpolator</a><a href="Imaging_Core_ImageInterpolator.html" class="sidebar-link">ImageInterpolator</a><a href="Imaging_Core_ImagePointDataIterator.html" class="sidebar-link">ImagePointDataIterator</a><a href="Imaging_Core_ImageReslice.html" class="sidebar-link">ImageReslice</a><strong class="sidebar-title">Imaging/Hybrid</strong><a href="Imaging_Hybrid_SampleFunction.html" class="sidebar-link">SampleFunction</a><strong class="sidebar-title">Interaction/Animations</strong><a href="Interaction_Animations_TimeStepBasedAnimationHandler.html" class="sidebar-link">TimeStepBasedAnimationHandler</a><strong class="sidebar-title">Interaction/Manipulators</strong><a href="Interaction_Manipulators_CompositeCameraManipulator.html" class="sidebar-link">CompositeCameraManipulator</a><a href="Interaction_Manipulators_CompositeGestureManipulator.html" class="sidebar-link">CompositeGestureManipulator</a><a href="Interaction_Manipulators_CompositeKeyboardManipulator.html" class="sidebar-link">CompositeKeyboardManipulator</a><a href="Interaction_Manipulators_CompositeMouseManipulator.html" class="sidebar-link">CompositeMouseManipulator</a><a href="Interaction_Manipulators_CompositeVRManipulator.html" class="sidebar-link">CompositeVRManipulator</a><a href="Interaction_Manipulators_GestureCameraManipulator.html" class="sidebar-link">GestureCameraManipulator</a><a href="Interaction_Manipulators_KeyboardCameraManipulator.html" class="sidebar-link">KeyboardCameraManipulator</a><a href="Interaction_Manipulators_MouseBoxSelectorManipulator.html" class="sidebar-link">MouseBoxSelectorManipulator</a><a href="Interaction_Manipulators_MouseCameraAxisRotateManipulator.html" class="sidebar-link">MouseCameraAxisRotateManipulator</a><a href="Interaction_Manipulators_MouseCameraSliceManipulator.html" class="sidebar-link">MouseCameraSliceManipulator</a><a href="Interaction_Manipulators_MouseCameraTrackballFirstPersonManipulator.html" class="sidebar-link">MouseCameraTrackballFirstPersonManipulator</a><a href="Interaction_Manipulators_MouseCameraTrackballMultiRotateManipulator.html" class="sidebar-link">MouseCameraTrackballMultiRotateManipulator</a><a href="Interaction_Manipulators_MouseCameraTrackballPanManipulator.html" class="sidebar-link">MouseCameraTrackballPanManipulator</a><a href="Interaction_Manipulators_MouseCameraTrackballRollManipulator.html" class="sidebar-link">MouseCameraTrackballRollManipulator</a><a href="Interaction_Manipulators_MouseCameraTrackballRotateManipulator.html" class="sidebar-link">MouseCameraTrackballRotateManipulator</a><a href="Interaction_Manipulators_MouseCameraTrackballZoomManipulator.html" class="sidebar-link">MouseCameraTrackballZoomManipulator</a><a href="Interaction_Manipulators_MouseCameraTrackballZoomToMouseManipulator.html" class="sidebar-link">MouseCameraTrackballZoomToMouseManipulator</a><a href="Interaction_Manipulators_MouseCameraUnicamManipulator.html" class="sidebar-link">MouseCameraUnicamManipulator</a><a href="Interaction_Manipulators_MouseCameraUnicamRotateManipulator.html" class="sidebar-link">MouseCameraUnicamRotateManipulator</a><a href="Interaction_Manipulators_MouseRangeManipulator.html" class="sidebar-link">MouseRangeManipulator</a><a href="Interaction_Manipulators_VRButtonPanManipulator.html" class="sidebar-link">VRButtonPanManipulator</a><strong class="sidebar-title">Interaction/Misc</strong><a href="Interaction_Misc_DeviceOrientationToCamera.html" class="sidebar-link">DeviceOrientationToCamera</a><strong class="sidebar-title">Interaction/Style</strong><a href="Interaction_Style_InteractorStyleImage.html" class="sidebar-link">InteractorStyleImage</a><a href="Interaction_Style_InteractorStyleMPRSlice.html" class="sidebar-link">InteractorStyleMPRSlice</a><a href="Interaction_Style_InteractorStyleManipulator.html" class="sidebar-link">InteractorStyleManipulator</a><a href="Interaction_Style_InteractorStyleRemoteMouse.html" class="sidebar-link">InteractorStyleRemoteMouse</a><a href="Interaction_Style_InteractorStyleTrackballCamera.html" class="sidebar-link">InteractorStyleTrackballCamera</a><a href="Interaction_Style_InteractorStyleUnicam.html" class="sidebar-link">InteractorStyleUnicam</a><strong class="sidebar-title">Interaction/UI</strong><a href="Interaction_UI_CornerAnnotation.html" class="sidebar-link">CornerAnnotation</a><a href="Interaction_UI_FPSMonitor.html" class="sidebar-link">FPSMonitor</a><a href="Interaction_UI_Icons.html" class="sidebar-link">Icons</a><a href="Interaction_UI_Slider.html" class="sidebar-link">Slider</a><a href="Interaction_UI_VolumeController.html" class="sidebar-link">VolumeController</a><strong class="sidebar-title">Interaction/Widgets</strong><a href="Interaction_Widgets_OrientationMarkerWidget.html" class="sidebar-link">OrientationMarkerWidget</a><a href="Interaction_Widgets_PiecewiseGaussianWidget.html" class="sidebar-link">PiecewiseGaussianWidget</a><strong class="sidebar-title">IO/Core</strong><a href="IO_Core_BinaryHelper.html" class="sidebar-link">BinaryHelper</a><a href="IO_Core_DataAccessHelper.html" class="sidebar-link">DataAccessHelper</a><a href="IO_Core_HttpDataSetReader.html" class="sidebar-link">HttpDataSetReader</a><a href="IO_Core_HttpDataSetSeriesReader.html" class="sidebar-link">HttpDataSetSeriesReader</a><a href="IO_Core_HttpSceneLoader.html" class="sidebar-link">HttpSceneLoader</a><a href="IO_Core_ImageStream.html" class="sidebar-link">ImageStream</a><a href="IO_Core_ResourceLoader.html" class="sidebar-link">ResourceLoader</a><a href="IO_Core_Serializer.html" class="sidebar-link">Serializer</a><a href="IO_Core_WSLinkClient.html" class="sidebar-link">WSLinkClient</a><a href="IO_Core_ZipMultiDataSetReader.html" class="sidebar-link">ZipMultiDataSetReader</a><a href="IO_Core_ZipMultiDataSetWriter.html" class="sidebar-link">ZipMultiDataSetWriter</a><strong class="sidebar-title">IO/Geometry</strong><a href="IO_Geometry_DracoReader.html" class="sidebar-link">DracoReader</a><a href="IO_Geometry_PLYReader.html" class="sidebar-link">PLYReader</a><a href="IO_Geometry_PLYWriter.html" class="sidebar-link">PLYWriter</a><a href="IO_Geometry_STLReader.html" class="sidebar-link">STLReader</a><a href="IO_Geometry_STLWriter.html" class="sidebar-link">STLWriter</a><strong class="sidebar-title">IO/Legacy</strong><a href="IO_Legacy_LegacyAsciiParser.html" class="sidebar-link">LegacyAsciiParser</a><a href="IO_Legacy_PolyDataReader.html" class="sidebar-link">PolyDataReader</a><strong class="sidebar-title">IO/Misc</strong><a href="IO_Misc_ElevationReader.html" class="sidebar-link">ElevationReader</a><a href="IO_Misc_HttpDataSetLODsLoader.html" class="sidebar-link">HttpDataSetLODsLoader</a><a href="IO_Misc_ITKImageReader.html" class="sidebar-link">ITKImageReader</a><a href="IO_Misc_ITKPolyDataReader.html" class="sidebar-link">ITKPolyDataReader</a><a href="IO_Misc_JSONNucleoReader.html" class="sidebar-link">JSONNucleoReader</a><a href="IO_Misc_JSONReader.html" class="sidebar-link">JSONReader</a><a href="IO_Misc_MTLReader.html" class="sidebar-link">MTLReader</a><a href="IO_Misc_OBJReader.html" class="sidebar-link">OBJReader</a><a href="IO_Misc_PDBReader.html" class="sidebar-link">PDBReader</a><a href="IO_Misc_SkyboxReader.html" class="sidebar-link">SkyboxReader</a><strong class="sidebar-title">IO/XML</strong><a href="IO_XML_XMLImageDataReader.html" class="sidebar-link">XMLImageDataReader</a><a href="IO_XML_XMLImageDataWriter.html" class="sidebar-link">XMLImageDataWriter</a><a href="IO_XML_XMLPolyDataReader.html" class="sidebar-link">XMLPolyDataReader</a><a href="IO_XML_XMLPolyDataWriter.html" class="sidebar-link">XMLPolyDataWriter</a><a href="IO_XML_XMLReader.html" class="sidebar-link">XMLReader</a><a href="IO_XML_XMLWriter.html" class="sidebar-link">XMLWriter</a><strong class="sidebar-title">Proxy/Animation</strong><a href="Proxy_Animation_AbstractAnimationProxy.html" class="sidebar-link">AbstractAnimationProxy</a><a href="Proxy_Animation_AnimationProxyManager.html" class="sidebar-link">AnimationProxyManager</a><a href="Proxy_Animation_TimeStepBasedAnimationHandlerProxy.html" class="sidebar-link">TimeStepBasedAnimationHandlerProxy</a><strong class="sidebar-title">Proxy/Core</strong><a href="Proxy_Core_AbstractRepresentationProxy.html" class="sidebar-link">AbstractRepresentationProxy</a><a href="Proxy_Core_LookupTableProxy.html" class="sidebar-link">LookupTableProxy</a><a href="Proxy_Core_PiecewiseFunctionProxy.html" class="sidebar-link">PiecewiseFunctionProxy</a><a href="Proxy_Core_ProxyManager.html" class="sidebar-link">ProxyManager</a><a href="Proxy_Core_SourceProxy.html" class="sidebar-link">SourceProxy</a><a href="Proxy_Core_View2DProxy.html" class="sidebar-link">View2DProxy</a><a href="Proxy_Core_ViewProxy.html" class="sidebar-link">ViewProxy</a><strong class="sidebar-title">Proxy/Representations</strong><a href="Proxy_Representations_GeometryRepresentationProxy.html" class="sidebar-link">GeometryRepresentationProxy</a><a href="Proxy_Representations_GlyphRepresentationProxy.html" class="sidebar-link">GlyphRepresentationProxy</a><a href="Proxy_Representations_MoleculeRepresentationProxy.html" class="sidebar-link">MoleculeRepresentationProxy</a><a href="Proxy_Representations_ResliceRepresentationProxy.html" class="sidebar-link">ResliceRepresentationProxy</a><a href="Proxy_Representations_SkyboxRepresentationProxy.html" class="sidebar-link">SkyboxRepresentationProxy</a><a href="Proxy_Representations_SliceRepresentationProxy.html" class="sidebar-link">SliceRepresentationProxy</a><a href="Proxy_Representations_SlicedGeometryRepresentationProxy.html" class="sidebar-link">SlicedGeometryRepresentationProxy</a><a href="Proxy_Representations_VolumeRepresentationProxy.html" class="sidebar-link">VolumeRepresentationProxy</a><strong class="sidebar-title">Rendering/Core</strong><a href="Rendering_Core_AbstractImageMapper.html" class="sidebar-link">AbstractImageMapper</a><a href="Rendering_Core_AbstractMapper.html" class="sidebar-link">AbstractMapper</a><a href="Rendering_Core_AbstractMapper3D.html" class="sidebar-link">AbstractMapper3D</a><a href="Rendering_Core_AbstractPicker.html" class="sidebar-link">AbstractPicker</a><a href="Rendering_Core_Actor.html" class="sidebar-link">Actor</a><a href="Rendering_Core_Actor2D.html" class="sidebar-link">Actor2D</a><a href="Rendering_Core_AnnotatedCubeActor.html" class="sidebar-link">AnnotatedCubeActor</a><a href="Rendering_Core_AxesActor.html" class="sidebar-link">AxesActor</a><a href="Rendering_Core_Camera.html" class="sidebar-link">Camera</a><a href="Rendering_Core_CellPicker.html" class="sidebar-link">CellPicker</a><a href="Rendering_Core_ColorTransferFunction.html" class="sidebar-link">ColorTransferFunction</a><a href="Rendering_Core_Coordinate.html" class="sidebar-link">Coordinate</a><a href="Rendering_Core_CubeAxesActor.html" class="sidebar-link">CubeAxesActor</a><a href="Rendering_Core_Follower.html" class="sidebar-link">Follower</a><a href="Rendering_Core_Glyph3DMapper.html" class="sidebar-link">Glyph3DMapper</a><a href="Rendering_Core_HardwareSelector.html" class="sidebar-link">HardwareSelector</a><a href="Rendering_Core_ImageArrayMapper.html" class="sidebar-link">ImageArrayMapper</a><a href="Rendering_Core_ImageCPRMapper.html" class="sidebar-link">ImageCPRMapper</a><a href="Rendering_Core_ImageMapper.html" class="sidebar-link">ImageMapper</a><a href="Rendering_Core_ImageProperty.html" class="sidebar-link">ImageProperty</a><a href="Rendering_Core_ImageResliceMapper.html" class="sidebar-link">ImageResliceMapper</a><a href="Rendering_Core_ImageSlice.html" class="sidebar-link">ImageSlice</a><a href="Rendering_Core_InteractorObserver.html" class="sidebar-link">InteractorObserver</a><a href="Rendering_Core_InteractorStyle.html" class="sidebar-link">InteractorStyle</a><a href="Rendering_Core_Light.html" class="sidebar-link">Light</a><a href="Rendering_Core_Mapper.html" class="sidebar-link">Mapper</a><a href="Rendering_Core_Mapper2D.html" class="sidebar-link">Mapper2D</a><a href="Rendering_Core_Picker.html" class="sidebar-link">Picker</a><a href="Rendering_Core_PixelSpaceCallbackMapper.html" class="sidebar-link">PixelSpaceCallbackMapper</a><a href="Rendering_Core_PointPicker.html" class="sidebar-link">PointPicker</a><a href="Rendering_Core_Prop.html" class="sidebar-link">Prop</a><a href="Rendering_Core_Prop3D.html" class="sidebar-link">Prop3D</a><a href="Rendering_Core_Property.html" class="sidebar-link">Property</a><a href="Rendering_Core_Property2D.html" class="sidebar-link">Property2D</a><a href="Rendering_Core_RenderWindow.html" class="sidebar-link">RenderWindow</a><a href="Rendering_Core_RenderWindowInteractor.html" class="sidebar-link">RenderWindowInteractor</a><a href="Rendering_Core_Renderer.html" class="sidebar-link">Renderer</a><a href="Rendering_Core_ScalarBarActor.html" class="sidebar-link">ScalarBarActor</a><a href="Rendering_Core_Skybox.html" class="sidebar-link">Skybox</a><a href="Rendering_Core_SphereMapper.html" class="sidebar-link">SphereMapper</a><a href="Rendering_Core_StickMapper.html" class="sidebar-link">StickMapper</a><a href="Rendering_Core_SurfaceLICInterface.html" class="sidebar-link">SurfaceLICInterface</a><a href="Rendering_Core_SurfaceLICMapper.html" class="sidebar-link">SurfaceLICMapper</a><a href="Rendering_Core_Texture.html" class="sidebar-link">Texture</a><a href="Rendering_Core_Viewport.html" class="sidebar-link">Viewport</a><a href="Rendering_Core_Volume.html" class="sidebar-link">Volume</a><a href="Rendering_Core_VolumeMapper.html" class="sidebar-link">VolumeMapper</a><a href="Rendering_Core_VolumeProperty.html" class="sidebar-link">VolumeProperty</a><strong class="sidebar-title">Rendering/Misc</strong><a href="Rendering_Misc_CanvasView.html" class="sidebar-link">CanvasView</a><a href="Rendering_Misc_FullScreenRenderWindow.html" class="sidebar-link">FullScreenRenderWindow</a><a href="Rendering_Misc_GenericRenderWindow.html" class="sidebar-link">GenericRenderWindow</a><a href="Rendering_Misc_RemoteView.html" class="sidebar-link">RemoteView</a><a href="Rendering_Misc_RenderWindowWithControlBar.html" class="sidebar-link">RenderWindowWithControlBar</a><a href="Rendering_Misc_RenderingAPIs.html" class="sidebar-link">RenderingAPIs</a><a href="Rendering_Misc_SynchronizableRenderWindow.html" class="sidebar-link">SynchronizableRenderWindow</a><a href="Rendering_Misc_TextureLODsDownloader.html" class="sidebar-link">TextureLODsDownloader</a><strong class="sidebar-title">Rendering/OpenGL</strong><a href="Rendering_OpenGL_Actor.html" class="sidebar-link">Actor</a><a href="Rendering_OpenGL_Actor2D.html" class="sidebar-link">Actor2D</a><a href="Rendering_OpenGL_BufferObject.html" class="sidebar-link">BufferObject</a><a href="Rendering_OpenGL_Camera.html" class="sidebar-link">Camera</a><a href="Rendering_OpenGL_CellArrayBufferObject.html" class="sidebar-link">CellArrayBufferObject</a><a href="Rendering_OpenGL_Convolution2DPass.html" class="sidebar-link">Convolution2DPass</a><a href="Rendering_OpenGL_CubeAxesActor.html" class="sidebar-link">CubeAxesActor</a><a href="Rendering_OpenGL_ForwardPass.html" class="sidebar-link">ForwardPass</a><a href="Rendering_OpenGL_Framebuffer.html" class="sidebar-link">Framebuffer</a><a href="Rendering_OpenGL_Glyph3DMapper.html" class="sidebar-link">Glyph3DMapper</a><a href="Rendering_OpenGL_HardwareSelector.html" class="sidebar-link">HardwareSelector</a><a href="Rendering_OpenGL_Helper.html" class="sidebar-link">Helper</a><a href="Rendering_OpenGL_ImageCPRMapper.html" class="sidebar-link">ImageCPRMapper</a><a href="Rendering_OpenGL_ImageMapper.html" class="sidebar-link">ImageMapper</a><a href="Rendering_OpenGL_ImageResliceMapper.html" class="sidebar-link">ImageResliceMapper</a><a href="Rendering_OpenGL_ImageSlice.html" class="sidebar-link">ImageSlice</a><a href="Rendering_OpenGL_OrderIndependentTranslucentPass.html" class="sidebar-link">OrderIndependentTranslucentPass</a><a href="Rendering_OpenGL_PixelSpaceCallbackMapper.html" class="sidebar-link">PixelSpaceCallbackMapper</a><a href="Rendering_OpenGL_PolyDataMapper.html" class="sidebar-link">PolyDataMapper</a><a href="Rendering_OpenGL_PolyDataMapper2D.html" class="sidebar-link">PolyDataMapper2D</a><a href="Rendering_OpenGL_Profiles.html" class="sidebar-link">Profiles</a><a href="Rendering_OpenGL_RadialDistortionPass.html" class="sidebar-link">RadialDistortionPass</a><a href="Rendering_OpenGL_RenderWindow.html" class="sidebar-link">RenderWindow</a><a href="Rendering_OpenGL_Renderer.html" class="sidebar-link">Renderer</a><a href="Rendering_OpenGL_ReplacementShaderMapper.html" class="sidebar-link">ReplacementShaderMapper</a><a href="Rendering_OpenGL_ScalarBarActor.html" class="sidebar-link">ScalarBarActor</a><a href="Rendering_OpenGL_Shader.html" class="sidebar-link">Shader</a><a href="Rendering_OpenGL_ShaderCache.html" class="sidebar-link">ShaderCache</a><a href="Rendering_OpenGL_ShaderProgram.html" class="sidebar-link">ShaderProgram</a><a href="Rendering_OpenGL_Skybox.html" class="sidebar-link">Skybox</a><a href="Rendering_OpenGL_SphereMapper.html" class="sidebar-link">SphereMapper</a><a href="Rendering_OpenGL_StickMapper.html" class="sidebar-link">StickMapper</a><a href="Rendering_OpenGL_SurfaceLIC.html" class="sidebar-link">SurfaceLIC</a><a href="Rendering_OpenGL_Texture.html" class="sidebar-link">Texture</a><a href="Rendering_OpenGL_TextureUnitManager.html" class="sidebar-link">TextureUnitManager</a><a href="Rendering_OpenGL_VertexArrayObject.html" class="sidebar-link">VertexArrayObject</a><a href="Rendering_OpenGL_ViewNodeFactory.html" class="sidebar-link">ViewNodeFactory</a><a href="Rendering_OpenGL_Volume.html" class="sidebar-link">Volume</a><a href="Rendering_OpenGL_VolumeMapper.html" class="sidebar-link">VolumeMapper</a><a href="Rendering_OpenGL_glsl.html" class="sidebar-link">glsl</a><strong class="sidebar-title">Rendering/Profiles</strong><strong class="sidebar-title">Rendering/SceneGraph</strong><a href="Rendering_SceneGraph_RenderPass.html" class="sidebar-link">RenderPass</a><a href="Rendering_SceneGraph_RenderWindowViewNode.html" class="sidebar-link">RenderWindowViewNode</a><a href="Rendering_SceneGraph_ViewNode.html" class="sidebar-link">ViewNode</a><a href="Rendering_SceneGraph_ViewNodeFactory.html" class="sidebar-link">ViewNodeFactory</a><strong class="sidebar-title">Rendering/WebGPU</strong><a href="Rendering_WebGPU_Actor.html" class="sidebar-link">Actor</a><a href="Rendering_WebGPU_Actor2D.html" class="sidebar-link">Actor2D</a><a href="Rendering_WebGPU_BindGroup.html" class="sidebar-link">BindGroup</a><a href="Rendering_WebGPU_Buffer.html" class="sidebar-link">Buffer</a><a href="Rendering_WebGPU_BufferManager.html" class="sidebar-link">BufferManager</a><a href="Rendering_WebGPU_Camera.html" class="sidebar-link">Camera</a><a href="Rendering_WebGPU_CellArrayMapper.html" class="sidebar-link">CellArrayMapper</a><a href="Rendering_WebGPU_CubeAxesActor.html" class="sidebar-link">CubeAxesActor</a><a href="Rendering_WebGPU_Device.html" class="sidebar-link">Device</a><a href="Rendering_WebGPU_ForwardPass.html" class="sidebar-link">ForwardPass</a><a href="Rendering_WebGPU_FullScreenQuad.html" class="sidebar-link">FullScreenQuad</a><a href="Rendering_WebGPU_Glyph3DMapper.html" class="sidebar-link">Glyph3DMapper</a><a href="Rendering_WebGPU_HardwareSelectionPass.html" class="sidebar-link">HardwareSelectionPass</a><a href="Rendering_WebGPU_HardwareSelector.html" class="sidebar-link">HardwareSelector</a><a href="Rendering_WebGPU_ImageMapper.html" class="sidebar-link">ImageMapper</a><a href="Rendering_WebGPU_ImageSlice.html" class="sidebar-link">ImageSlice</a><a href="Rendering_WebGPU_IndexBuffer.html" class="sidebar-link">IndexBuffer</a><a href="Rendering_WebGPU_OpaquePass.html" class="sidebar-link">OpaquePass</a><a href="Rendering_WebGPU_OrderIndependentTranslucentPass.html" class="sidebar-link">OrderIndependentTranslucentPass</a><a href="Rendering_WebGPU_Pipeline.html" class="sidebar-link">Pipeline</a><a href="Rendering_WebGPU_PixelSpaceCallbackMapper.html" class="sidebar-link">PixelSpaceCallbackMapper</a><a href="Rendering_WebGPU_PolyDataMapper.html" class="sidebar-link">PolyDataMapper</a><a href="Rendering_WebGPU_PolyDataMapper2D.html" class="sidebar-link">PolyDataMapper2D</a><a href="Rendering_WebGPU_Profiles.html" class="sidebar-link">Profiles</a><a href="Rendering_WebGPU_RenderEncoder.html" class="sidebar-link">RenderEncoder</a><a href="Rendering_WebGPU_RenderWindow.html" class="sidebar-link">RenderWindow</a><a href="Rendering_WebGPU_Renderer.html" class="sidebar-link">Renderer</a><a href="Rendering_WebGPU_Sampler.html" class="sidebar-link">Sampler</a><a href="Rendering_WebGPU_ScalarBarActor.html" class="sidebar-link">ScalarBarActor</a><a href="Rendering_WebGPU_ShaderCache.html" class="sidebar-link">ShaderCache</a><a href="Rendering_WebGPU_ShaderDescription.html" class="sidebar-link">ShaderDescription</a><a href="Rendering_WebGPU_ShaderModule.html" class="sidebar-link">ShaderModule</a><a href="Rendering_WebGPU_SimpleMapper.html" class="sidebar-link">SimpleMapper</a><a href="Rendering_WebGPU_SphereMapper.html" class="sidebar-link">SphereMapper</a><a href="Rendering_WebGPU_StickMapper.html" class="sidebar-link">StickMapper</a><a href="Rendering_WebGPU_StorageBuffer.html" class="sidebar-link">StorageBuffer</a><a href="Rendering_WebGPU_Texture.html" class="sidebar-link">Texture</a><a href="Rendering_WebGPU_TextureManager.html" class="sidebar-link">TextureManager</a><a href="Rendering_WebGPU_TextureView.html" class="sidebar-link">TextureView</a><a href="Rendering_WebGPU_Types.html" class="sidebar-link">Types</a><a href="Rendering_WebGPU_UniformBuffer.html" class="sidebar-link">UniformBuffer</a><a href="Rendering_WebGPU_VertexInput.html" class="sidebar-link">VertexInput</a><a href="Rendering_WebGPU_ViewNodeFactory.html" class="sidebar-link">ViewNodeFactory</a><a href="Rendering_WebGPU_Volume.html" class="sidebar-link">Volume</a><a href="Rendering_WebGPU_VolumePass.html" class="sidebar-link">VolumePass</a><a href="Rendering_WebGPU_VolumePassFSQ.html" class="sidebar-link">VolumePassFSQ</a><strong class="sidebar-title">Rendering/WebXR</strong><a href="Rendering_WebXR_RenderWindowHelper.html" class="sidebar-link">RenderWindowHelper</a><strong class="sidebar-title">Testing/Examples</strong><a href="Testing_Examples_ActorSerialization.html" class="sidebar-link">ActorSerialization</a><a href="Testing_Examples_PipelineExecution.html" class="sidebar-link">PipelineExecution</a><a href="Testing_Examples_PolyDataSerialization.html" class="sidebar-link">PolyDataSerialization</a><a href="Testing_Examples_StandaloneSceneLoader.html" class="sidebar-link">StandaloneSceneLoader</a><a href="Testing_Examples_WindTunnel.html" class="sidebar-link">WindTunnel</a><strong class="sidebar-title">Widgets/Core</strong><a href="Widgets_Core_AbstractWidget.html" class="sidebar-link">AbstractWidget</a><a href="Widgets_Core_AbstractWidgetFactory.html" class="sidebar-link">AbstractWidgetFactory</a><a href="Widgets_Core_StateBuilder.html" class="sidebar-link">StateBuilder</a><a href="Widgets_Core_WidgetManager.html" class="sidebar-link">WidgetManager</a><a href="Widgets_Core_WidgetState.html" class="sidebar-link">WidgetState</a><strong class="sidebar-title">Widgets/Manipulators</strong><a href="Widgets_Manipulators_AbstractManipulator.html" class="sidebar-link">AbstractManipulator</a><a href="Widgets_Manipulators_CPRManipulator.html" class="sidebar-link">CPRManipulator</a><a href="Widgets_Manipulators_LineManipulator.html" class="sidebar-link">LineManipulator</a><a href="Widgets_Manipulators_PickerManipulator.html" class="sidebar-link">PickerManipulator</a><a href="Widgets_Manipulators_PlaneManipulator.html" class="sidebar-link">PlaneManipulator</a><a href="Widgets_Manipulators_TrackballManipulator.html" class="sidebar-link">TrackballManipulator</a><strong class="sidebar-title">Widgets/Representations</strong><a href="Widgets_Representations_ArrowHandleRepresentation.html" class="sidebar-link">ArrowHandleRepresentation</a><a href="Widgets_Representations_CircleContextRepresentation.html" class="sidebar-link">CircleContextRepresentation</a><a href="Widgets_Representations_ContextRepresentation.html" class="sidebar-link">ContextRepresentation</a><a href="Widgets_Representations_ConvexFaceContextRepresentation.html" class="sidebar-link">ConvexFaceContextRepresentation</a><a href="Widgets_Representations_CroppingOutlineRepresentation.html" class="sidebar-link">CroppingOutlineRepresentation</a><a href="Widgets_Representations_CubeHandleRepresentation.html" class="sidebar-link">CubeHandleRepresentation</a><a href="Widgets_Representations_GlyphRepresentation.html" class="sidebar-link">GlyphRepresentation</a><a href="Widgets_Representations_HandleRepresentation.html" class="sidebar-link">HandleRepresentation</a><a href="Widgets_Representations_ImplicitPlaneRepresentation.html" class="sidebar-link">ImplicitPlaneRepresentation</a><a href="Widgets_Representations_LineHandleRepresentation.html" class="sidebar-link">LineHandleRepresentation</a><a href="Widgets_Representations_OutlineContextRepresentation.html" class="sidebar-link">OutlineContextRepresentation</a><a href="Widgets_Representations_PolyLineRepresentation.html" class="sidebar-link">PolyLineRepresentation</a><a href="Widgets_Representations_RectangleContextRepresentation.html" class="sidebar-link">RectangleContextRepresentation</a><a href="Widgets_Representations_SphereContextRepresentation.html" class="sidebar-link">SphereContextRepresentation</a><a href="Widgets_Representations_SphereHandleRepresentation.html" class="sidebar-link">SphereHandleRepresentation</a><a href="Widgets_Representations_SplineContextRepresentation.html" class="sidebar-link">SplineContextRepresentation</a><a href="Widgets_Representations_WidgetRepresentation.html" class="sidebar-link">WidgetRepresentation</a><strong class="sidebar-title">Widgets/Widgets3D</strong><a href="Widgets_Widgets3D_AngleWidget.html" class="sidebar-link">AngleWidget</a><a href="Widgets_Widgets3D_EllipseWidget.html" class="sidebar-link">EllipseWidget</a><a href="Widgets_Widgets3D_ImageCroppingWidget.html" class="sidebar-link">ImageCroppingWidget</a><a href="Widgets_Widgets3D_ImplicitPlaneWidget.html" class="sidebar-link">ImplicitPlaneWidget</a><a href="Widgets_Widgets3D_InteractiveOrientationWidget.html" class="sidebar-link">InteractiveOrientationWidget</a><a href="Widgets_Widgets3D_LabelWidget.html" class="sidebar-link">LabelWidget</a><a href="Widgets_Widgets3D_LineWidget.html" class="sidebar-link">LineWidget</a><a href="Widgets_Widgets3D_PaintWidget.html" class="sidebar-link">PaintWidget</a><a href="Widgets_Widgets3D_PolyLineWidget.html" class="sidebar-link">PolyLineWidget</a><a href="Widgets_Widgets3D_RectangleWidget.html" class="sidebar-link">RectangleWidget</a><a href="Widgets_Widgets3D_ResliceCursorWidget.html" class="sidebar-link">ResliceCursorWidget</a><a href="Widgets_Widgets3D_SeedWidget.html" class="sidebar-link">SeedWidget</a><a href="Widgets_Widgets3D_ShapeWidget.html" class="sidebar-link">ShapeWidget</a><a href="Widgets_Widgets3D_SphereWidget.html" class="sidebar-link">SphereWidget</a><a href="Widgets_Widgets3D_SplineWidget.html" class="sidebar-link">SplineWidget</a></div>
</aside>
    </div>
  </div>
</div>

    <footer id="footer" class="wrapper">
  <div class="inner">
    <div id="footer-copyright">
      &copy; 2024 <a href="https://www.kitware.com/" target="_blank">Kitware Inc.</a>
    </div>

    <div id="footer-links">
      <a href="https://github.com/kitware/vtk-js" class="footer-link" target="_blank"><i class="fa fa-github-alt"></i></a>
    </div>
  </div>
    <a
      style="position: fixed; background: #00529b; color: white; top: 0; right: 0; height: 70px"
      target="_blank" rel="noopener" href="https://www.kitware.com/careers"
    >
      <div style="position: relative; text-align: center;">
        <div
          style="margin-top: 5px; background: url(https://www.cmake.org/wp-content/uploads/2018/09/jobs_icon.png) no-repeat; background-size: 100%; width: 50px; height: 40px; margin: 5px auto 0;"
        ></div>
        <span style="padding: 5px 10px">Kitware is Hiring</span>
      </div>
    </a>
</footer>

  </div>
  <div id="mobile-nav-dimmer"></div>
  <nav id="mobile-nav">
  <div id="mobile-nav-inner">
    <ul id="mobile-nav-list">
      <a href="/vtk-js/docs/" class="mobile-nav-link">Docs</a><a href="/vtk-js/api/" class="mobile-nav-link">API</a><a href="/vtk-js/examples/" class="mobile-nav-link">Examples</a><a href="https://kitware.github.io/vtk-js-datasets/" class="mobile-nav-link">Sample data</a>
      <li class="mobile-nav-item">
        <a href="https://github.com/kitware/vtk-js" class="mobile-nav-link" rel="external" target="_blank">GitHub</a>
      </li>
    </ul>
    
      <strong class="mobile-nav-title">Common/Core</strong><a href="Common_Core_Base64.html" class="mobile-nav-link">Base64</a><a href="Common_Core_CellArray.html" class="mobile-nav-link">CellArray</a><a href="Common_Core_ClassHierarchy.html" class="mobile-nav-link">ClassHierarchy</a><a href="Common_Core_DataArray.html" class="mobile-nav-link">DataArray</a><a href="Common_Core_Endian.html" class="mobile-nav-link">Endian</a><a href="Common_Core_HalfFloat.html" class="mobile-nav-link">HalfFloat</a><a href="Common_Core_ImageHelper.html" class="mobile-nav-link">ImageHelper</a><a href="Common_Core_LookupTable.html" class="mobile-nav-link">LookupTable</a><a href="Common_Core_Math.html" class="mobile-nav-link">Math</a><a href="Common_Core_MatrixBuilder.html" class="mobile-nav-link">MatrixBuilder</a><a href="Common_Core_Points.html" class="mobile-nav-link">Points</a><a href="Common_Core_PriorityQueue.html" class="mobile-nav-link">PriorityQueue</a><a href="Common_Core_ProgressHandler.html" class="mobile-nav-link">ProgressHandler</a><a href="Common_Core_ScalarsToColors.html" class="mobile-nav-link">ScalarsToColors</a><a href="Common_Core_StringArray.html" class="mobile-nav-link">StringArray</a><a href="Common_Core_URLExtract.html" class="mobile-nav-link">URLExtract</a><a href="Common_Core_VariantArray.html" class="mobile-nav-link">VariantArray</a><strong class="mobile-nav-title">Common/DataModel</strong><a href="Common_DataModel_AbstractPointLocator.html" class="mobile-nav-link">AbstractPointLocator</a><a href="Common_DataModel_BoundingBox.html" class="mobile-nav-link">BoundingBox</a><a href="Common_DataModel_Box.html" class="mobile-nav-link">Box</a><a href="Common_DataModel_CardinalSpline1D.html" class="mobile-nav-link">CardinalSpline1D</a><a href="Common_DataModel_Cell.html" class="mobile-nav-link">Cell</a><a href="Common_DataModel_CellLinks.html" class="mobile-nav-link">CellLinks</a><a href="Common_DataModel_CellTypes.html" class="mobile-nav-link">CellTypes</a><a href="Common_DataModel_Collection.html" class="mobile-nav-link">Collection</a><a href="Common_DataModel_Cone.html" class="mobile-nav-link">Cone</a><a href="Common_DataModel_Cylinder.html" class="mobile-nav-link">Cylinder</a><a href="Common_DataModel_DataSet.html" class="mobile-nav-link">DataSet</a><a href="Common_DataModel_DataSetAttributes.html" class="mobile-nav-link">DataSetAttributes</a><a href="Common_DataModel_EdgeLocator.html" class="mobile-nav-link">EdgeLocator</a><a href="Common_DataModel_ITKHelper.html" class="mobile-nav-link">ITKHelper</a><a href="Common_DataModel_ImageData.html" class="mobile-nav-link">ImageData</a><a href="Common_DataModel_ImplicitBoolean.html" class="mobile-nav-link">ImplicitBoolean</a><a href="Common_DataModel_IncrementalOctreeNode.html" class="mobile-nav-link">IncrementalOctreeNode</a><a href="Common_DataModel_IncrementalOctreePointLocator.html" class="mobile-nav-link">IncrementalOctreePointLocator</a><a href="Common_DataModel_KochanekSpline1D.html" class="mobile-nav-link">KochanekSpline1D</a><a href="Common_DataModel_Line.html" class="mobile-nav-link">Line</a><a href="Common_DataModel_Locator.html" class="mobile-nav-link">Locator</a><a href="Common_DataModel_Molecule.html" class="mobile-nav-link">Molecule</a><a href="Common_DataModel_PiecewiseFunction.html" class="mobile-nav-link">PiecewiseFunction</a><a href="Common_DataModel_Plane.html" class="mobile-nav-link">Plane</a><a href="Common_DataModel_PointSet.html" class="mobile-nav-link">PointSet</a><a href="Common_DataModel_PolyData.html" class="mobile-nav-link">PolyData</a><a href="Common_DataModel_PolyLine.html" class="mobile-nav-link">PolyLine</a><a href="Common_DataModel_Polygon.html" class="mobile-nav-link">Polygon</a><a href="Common_DataModel_Quad.html" class="mobile-nav-link">Quad</a><a href="Common_DataModel_SelectionNode.html" class="mobile-nav-link">SelectionNode</a><a href="Common_DataModel_Sphere.html" class="mobile-nav-link">Sphere</a><a href="Common_DataModel_Spline1D.html" class="mobile-nav-link">Spline1D</a><a href="Common_DataModel_Spline3D.html" class="mobile-nav-link">Spline3D</a><a href="Common_DataModel_StructuredData.html" class="mobile-nav-link">StructuredData</a><a href="Common_DataModel_Triangle.html" class="mobile-nav-link">Triangle</a><strong class="mobile-nav-title">Common/System</strong><a href="Common_System_MobileVR.html" class="mobile-nav-link">MobileVR</a><a href="Common_System_TimerLog.html" class="mobile-nav-link">TimerLog</a><strong class="mobile-nav-title">Common/Transform</strong><a href="Common_Transform_LandmarkTransform.html" class="mobile-nav-link">LandmarkTransform</a><a href="Common_Transform_Transform.html" class="mobile-nav-link">Transform</a><strong class="mobile-nav-title">Filters/Core</strong><a href="Filters_Core_Cutter.html" class="mobile-nav-link">Cutter</a><a href="Filters_Core_PolyDataNormals.html" class="mobile-nav-link">PolyDataNormals</a><strong class="mobile-nav-title">Filters/Cornerstone</strong><a href="Filters_Cornerstone_ImageDataToCornerstoneImage.html" class="mobile-nav-link">ImageDataToCornerstoneImage</a><strong class="mobile-nav-title">Filters/General</strong><a href="Filters_General_AppendPolyData.html" class="mobile-nav-link">AppendPolyData</a><a href="Filters_General_Calculator.html" class="mobile-nav-link">Calculator</a><a href="Filters_General_ClipClosedSurface.html" class="mobile-nav-link">ClipClosedSurface</a><a href="Filters_General_ClosedPolyLineToSurfaceFilter.html" class="mobile-nav-link">ClosedPolyLineToSurfaceFilter</a><a href="Filters_General_ContourLoopExtraction.html" class="mobile-nav-link">ContourLoopExtraction</a><a href="Filters_General_ContourTriangulator.html" class="mobile-nav-link current">ContourTriangulator</a><a href="Filters_General_ImageCropFilter.html" class="mobile-nav-link">ImageCropFilter</a><a href="Filters_General_ImageDataOutlineFilter.html" class="mobile-nav-link">ImageDataOutlineFilter</a><a href="Filters_General_ImageMarchingCubes.html" class="mobile-nav-link">ImageMarchingCubes</a><a href="Filters_General_ImageMarchingSquares.html" class="mobile-nav-link">ImageMarchingSquares</a><a href="Filters_General_ImageOutlineFilter.html" class="mobile-nav-link">ImageOutlineFilter</a><a href="Filters_General_ImageSliceFilter.html" class="mobile-nav-link">ImageSliceFilter</a><a href="Filters_General_ImageStreamline.html" class="mobile-nav-link">ImageStreamline</a><a href="Filters_General_LineFilter.html" class="mobile-nav-link">LineFilter</a><a href="Filters_General_MoleculeToRepresentation.html" class="mobile-nav-link">MoleculeToRepresentation</a><a href="Filters_General_OBBTree.html" class="mobile-nav-link">OBBTree</a><a href="Filters_General_OutlineFilter.html" class="mobile-nav-link">OutlineFilter</a><a href="Filters_General_PaintFilter.html" class="mobile-nav-link">PaintFilter</a><a href="Filters_General_ScalarToRGBA.html" class="mobile-nav-link">ScalarToRGBA</a><a href="Filters_General_TriangleFilter.html" class="mobile-nav-link">TriangleFilter</a><a href="Filters_General_TubeFilter.html" class="mobile-nav-link">TubeFilter</a><a href="Filters_General_WarpScalar.html" class="mobile-nav-link">WarpScalar</a><a href="Filters_General_WindowedSincPolyDataFilter.html" class="mobile-nav-link">WindowedSincPolyDataFilter</a><strong class="mobile-nav-title">Filters/Sources</strong><a href="Filters_Sources_Arrow2DSource.html" class="mobile-nav-link">Arrow2DSource</a><a href="Filters_Sources_ArrowSource.html" class="mobile-nav-link">ArrowSource</a><a href="Filters_Sources_CircleSource.html" class="mobile-nav-link">CircleSource</a><a href="Filters_Sources_ConcentricCylinderSource.html" class="mobile-nav-link">ConcentricCylinderSource</a><a href="Filters_Sources_ConeSource.html" class="mobile-nav-link">ConeSource</a><a href="Filters_Sources_CubeSource.html" class="mobile-nav-link">CubeSource</a><a href="Filters_Sources_Cursor3D.html" class="mobile-nav-link">Cursor3D</a><a href="Filters_Sources_CylinderSource.html" class="mobile-nav-link">CylinderSource</a><a href="Filters_Sources_ImageGridSource.html" class="mobile-nav-link">ImageGridSource</a><a href="Filters_Sources_LineSource.html" class="mobile-nav-link">LineSource</a><a href="Filters_Sources_PlaneSource.html" class="mobile-nav-link">PlaneSource</a><a href="Filters_Sources_PointSource.html" class="mobile-nav-link">PointSource</a><a href="Filters_Sources_RTAnalyticSource.html" class="mobile-nav-link">RTAnalyticSource</a><a href="Filters_Sources_SLICSource.html" class="mobile-nav-link">SLICSource</a><a href="Filters_Sources_SphereSource.html" class="mobile-nav-link">SphereSource</a><a href="Filters_Sources_ViewFinderSource.html" class="mobile-nav-link">ViewFinderSource</a><strong class="mobile-nav-title">Filters/Texture</strong><a href="Filters_Texture_TextureMapToPlane.html" class="mobile-nav-link">TextureMapToPlane</a><a href="Filters_Texture_TextureMapToSphere.html" class="mobile-nav-link">TextureMapToSphere</a><strong class="mobile-nav-title">Imaging/Core</strong><a href="Imaging_Core_AbstractImageInterpolator.html" class="mobile-nav-link">AbstractImageInterpolator</a><a href="Imaging_Core_ImageInterpolator.html" class="mobile-nav-link">ImageInterpolator</a><a href="Imaging_Core_ImagePointDataIterator.html" class="mobile-nav-link">ImagePointDataIterator</a><a href="Imaging_Core_ImageReslice.html" class="mobile-nav-link">ImageReslice</a><strong class="mobile-nav-title">Imaging/Hybrid</strong><a href="Imaging_Hybrid_SampleFunction.html" class="mobile-nav-link">SampleFunction</a><strong class="mobile-nav-title">Interaction/Animations</strong><a href="Interaction_Animations_TimeStepBasedAnimationHandler.html" class="mobile-nav-link">TimeStepBasedAnimationHandler</a><strong class="mobile-nav-title">Interaction/Manipulators</strong><a href="Interaction_Manipulators_CompositeCameraManipulator.html" class="mobile-nav-link">CompositeCameraManipulator</a><a href="Interaction_Manipulators_CompositeGestureManipulator.html" class="mobile-nav-link">CompositeGestureManipulator</a><a href="Interaction_Manipulators_CompositeKeyboardManipulator.html" class="mobile-nav-link">CompositeKeyboardManipulator</a><a href="Interaction_Manipulators_CompositeMouseManipulator.html" class="mobile-nav-link">CompositeMouseManipulator</a><a href="Interaction_Manipulators_CompositeVRManipulator.html" class="mobile-nav-link">CompositeVRManipulator</a><a href="Interaction_Manipulators_GestureCameraManipulator.html" class="mobile-nav-link">GestureCameraManipulator</a><a href="Interaction_Manipulators_KeyboardCameraManipulator.html" class="mobile-nav-link">KeyboardCameraManipulator</a><a href="Interaction_Manipulators_MouseBoxSelectorManipulator.html" class="mobile-nav-link">MouseBoxSelectorManipulator</a><a href="Interaction_Manipulators_MouseCameraAxisRotateManipulator.html" class="mobile-nav-link">MouseCameraAxisRotateManipulator</a><a href="Interaction_Manipulators_MouseCameraSliceManipulator.html" class="mobile-nav-link">MouseCameraSliceManipulator</a><a href="Interaction_Manipulators_MouseCameraTrackballFirstPersonManipulator.html" class="mobile-nav-link">MouseCameraTrackballFirstPersonManipulator</a><a href="Interaction_Manipulators_MouseCameraTrackballMultiRotateManipulator.html" class="mobile-nav-link">MouseCameraTrackballMultiRotateManipulator</a><a href="Interaction_Manipulators_MouseCameraTrackballPanManipulator.html" class="mobile-nav-link">MouseCameraTrackballPanManipulator</a><a href="Interaction_Manipulators_MouseCameraTrackballRollManipulator.html" class="mobile-nav-link">MouseCameraTrackballRollManipulator</a><a href="Interaction_Manipulators_MouseCameraTrackballRotateManipulator.html" class="mobile-nav-link">MouseCameraTrackballRotateManipulator</a><a href="Interaction_Manipulators_MouseCameraTrackballZoomManipulator.html" class="mobile-nav-link">MouseCameraTrackballZoomManipulator</a><a href="Interaction_Manipulators_MouseCameraTrackballZoomToMouseManipulator.html" class="mobile-nav-link">MouseCameraTrackballZoomToMouseManipulator</a><a href="Interaction_Manipulators_MouseCameraUnicamManipulator.html" class="mobile-nav-link">MouseCameraUnicamManipulator</a><a href="Interaction_Manipulators_MouseCameraUnicamRotateManipulator.html" class="mobile-nav-link">MouseCameraUnicamRotateManipulator</a><a href="Interaction_Manipulators_MouseRangeManipulator.html" class="mobile-nav-link">MouseRangeManipulator</a><a href="Interaction_Manipulators_VRButtonPanManipulator.html" class="mobile-nav-link">VRButtonPanManipulator</a><strong class="mobile-nav-title">Interaction/Misc</strong><a href="Interaction_Misc_DeviceOrientationToCamera.html" class="mobile-nav-link">DeviceOrientationToCamera</a><strong class="mobile-nav-title">Interaction/Style</strong><a href="Interaction_Style_InteractorStyleImage.html" class="mobile-nav-link">InteractorStyleImage</a><a href="Interaction_Style_InteractorStyleMPRSlice.html" class="mobile-nav-link">InteractorStyleMPRSlice</a><a href="Interaction_Style_InteractorStyleManipulator.html" class="mobile-nav-link">InteractorStyleManipulator</a><a href="Interaction_Style_InteractorStyleRemoteMouse.html" class="mobile-nav-link">InteractorStyleRemoteMouse</a><a href="Interaction_Style_InteractorStyleTrackballCamera.html" class="mobile-nav-link">InteractorStyleTrackballCamera</a><a href="Interaction_Style_InteractorStyleUnicam.html" class="mobile-nav-link">InteractorStyleUnicam</a><strong class="mobile-nav-title">Interaction/UI</strong><a href="Interaction_UI_CornerAnnotation.html" class="mobile-nav-link">CornerAnnotation</a><a href="Interaction_UI_FPSMonitor.html" class="mobile-nav-link">FPSMonitor</a><a href="Interaction_UI_Icons.html" class="mobile-nav-link">Icons</a><a href="Interaction_UI_Slider.html" class="mobile-nav-link">Slider</a><a href="Interaction_UI_VolumeController.html" class="mobile-nav-link">VolumeController</a><strong class="mobile-nav-title">Interaction/Widgets</strong><a href="Interaction_Widgets_OrientationMarkerWidget.html" class="mobile-nav-link">OrientationMarkerWidget</a><a href="Interaction_Widgets_PiecewiseGaussianWidget.html" class="mobile-nav-link">PiecewiseGaussianWidget</a><strong class="mobile-nav-title">IO/Core</strong><a href="IO_Core_BinaryHelper.html" class="mobile-nav-link">BinaryHelper</a><a href="IO_Core_DataAccessHelper.html" class="mobile-nav-link">DataAccessHelper</a><a href="IO_Core_HttpDataSetReader.html" class="mobile-nav-link">HttpDataSetReader</a><a href="IO_Core_HttpDataSetSeriesReader.html" class="mobile-nav-link">HttpDataSetSeriesReader</a><a href="IO_Core_HttpSceneLoader.html" class="mobile-nav-link">HttpSceneLoader</a><a href="IO_Core_ImageStream.html" class="mobile-nav-link">ImageStream</a><a href="IO_Core_ResourceLoader.html" class="mobile-nav-link">ResourceLoader</a><a href="IO_Core_Serializer.html" class="mobile-nav-link">Serializer</a><a href="IO_Core_WSLinkClient.html" class="mobile-nav-link">WSLinkClient</a><a href="IO_Core_ZipMultiDataSetReader.html" class="mobile-nav-link">ZipMultiDataSetReader</a><a href="IO_Core_ZipMultiDataSetWriter.html" class="mobile-nav-link">ZipMultiDataSetWriter</a><strong class="mobile-nav-title">IO/Geometry</strong><a href="IO_Geometry_DracoReader.html" class="mobile-nav-link">DracoReader</a><a href="IO_Geometry_PLYReader.html" class="mobile-nav-link">PLYReader</a><a href="IO_Geometry_PLYWriter.html" class="mobile-nav-link">PLYWriter</a><a href="IO_Geometry_STLReader.html" class="mobile-nav-link">STLReader</a><a href="IO_Geometry_STLWriter.html" class="mobile-nav-link">STLWriter</a><strong class="mobile-nav-title">IO/Legacy</strong><a href="IO_Legacy_LegacyAsciiParser.html" class="mobile-nav-link">LegacyAsciiParser</a><a href="IO_Legacy_PolyDataReader.html" class="mobile-nav-link">PolyDataReader</a><strong class="mobile-nav-title">IO/Misc</strong><a href="IO_Misc_ElevationReader.html" class="mobile-nav-link">ElevationReader</a><a href="IO_Misc_HttpDataSetLODsLoader.html" class="mobile-nav-link">HttpDataSetLODsLoader</a><a href="IO_Misc_ITKImageReader.html" class="mobile-nav-link">ITKImageReader</a><a href="IO_Misc_ITKPolyDataReader.html" class="mobile-nav-link">ITKPolyDataReader</a><a href="IO_Misc_JSONNucleoReader.html" class="mobile-nav-link">JSONNucleoReader</a><a href="IO_Misc_JSONReader.html" class="mobile-nav-link">JSONReader</a><a href="IO_Misc_MTLReader.html" class="mobile-nav-link">MTLReader</a><a href="IO_Misc_OBJReader.html" class="mobile-nav-link">OBJReader</a><a href="IO_Misc_PDBReader.html" class="mobile-nav-link">PDBReader</a><a href="IO_Misc_SkyboxReader.html" class="mobile-nav-link">SkyboxReader</a><strong class="mobile-nav-title">IO/XML</strong><a href="IO_XML_XMLImageDataReader.html" class="mobile-nav-link">XMLImageDataReader</a><a href="IO_XML_XMLImageDataWriter.html" class="mobile-nav-link">XMLImageDataWriter</a><a href="IO_XML_XMLPolyDataReader.html" class="mobile-nav-link">XMLPolyDataReader</a><a href="IO_XML_XMLPolyDataWriter.html" class="mobile-nav-link">XMLPolyDataWriter</a><a href="IO_XML_XMLReader.html" class="mobile-nav-link">XMLReader</a><a href="IO_XML_XMLWriter.html" class="mobile-nav-link">XMLWriter</a><strong class="mobile-nav-title">Proxy/Animation</strong><a href="Proxy_Animation_AbstractAnimationProxy.html" class="mobile-nav-link">AbstractAnimationProxy</a><a href="Proxy_Animation_AnimationProxyManager.html" class="mobile-nav-link">AnimationProxyManager</a><a href="Proxy_Animation_TimeStepBasedAnimationHandlerProxy.html" class="mobile-nav-link">TimeStepBasedAnimationHandlerProxy</a><strong class="mobile-nav-title">Proxy/Core</strong><a href="Proxy_Core_AbstractRepresentationProxy.html" class="mobile-nav-link">AbstractRepresentationProxy</a><a href="Proxy_Core_LookupTableProxy.html" class="mobile-nav-link">LookupTableProxy</a><a href="Proxy_Core_PiecewiseFunctionProxy.html" class="mobile-nav-link">PiecewiseFunctionProxy</a><a href="Proxy_Core_ProxyManager.html" class="mobile-nav-link">ProxyManager</a><a href="Proxy_Core_SourceProxy.html" class="mobile-nav-link">SourceProxy</a><a href="Proxy_Core_View2DProxy.html" class="mobile-nav-link">View2DProxy</a><a href="Proxy_Core_ViewProxy.html" class="mobile-nav-link">ViewProxy</a><strong class="mobile-nav-title">Proxy/Representations</strong><a href="Proxy_Representations_GeometryRepresentationProxy.html" class="mobile-nav-link">GeometryRepresentationProxy</a><a href="Proxy_Representations_GlyphRepresentationProxy.html" class="mobile-nav-link">GlyphRepresentationProxy</a><a href="Proxy_Representations_MoleculeRepresentationProxy.html" class="mobile-nav-link">MoleculeRepresentationProxy</a><a href="Proxy_Representations_ResliceRepresentationProxy.html" class="mobile-nav-link">ResliceRepresentationProxy</a><a href="Proxy_Representations_SkyboxRepresentationProxy.html" class="mobile-nav-link">SkyboxRepresentationProxy</a><a href="Proxy_Representations_SliceRepresentationProxy.html" class="mobile-nav-link">SliceRepresentationProxy</a><a href="Proxy_Representations_SlicedGeometryRepresentationProxy.html" class="mobile-nav-link">SlicedGeometryRepresentationProxy</a><a href="Proxy_Representations_VolumeRepresentationProxy.html" class="mobile-nav-link">VolumeRepresentationProxy</a><strong class="mobile-nav-title">Rendering/Core</strong><a href="Rendering_Core_AbstractImageMapper.html" class="mobile-nav-link">AbstractImageMapper</a><a href="Rendering_Core_AbstractMapper.html" class="mobile-nav-link">AbstractMapper</a><a href="Rendering_Core_AbstractMapper3D.html" class="mobile-nav-link">AbstractMapper3D</a><a href="Rendering_Core_AbstractPicker.html" class="mobile-nav-link">AbstractPicker</a><a href="Rendering_Core_Actor.html" class="mobile-nav-link">Actor</a><a href="Rendering_Core_Actor2D.html" class="mobile-nav-link">Actor2D</a><a href="Rendering_Core_AnnotatedCubeActor.html" class="mobile-nav-link">AnnotatedCubeActor</a><a href="Rendering_Core_AxesActor.html" class="mobile-nav-link">AxesActor</a><a href="Rendering_Core_Camera.html" class="mobile-nav-link">Camera</a><a href="Rendering_Core_CellPicker.html" class="mobile-nav-link">CellPicker</a><a href="Rendering_Core_ColorTransferFunction.html" class="mobile-nav-link">ColorTransferFunction</a><a href="Rendering_Core_Coordinate.html" class="mobile-nav-link">Coordinate</a><a href="Rendering_Core_CubeAxesActor.html" class="mobile-nav-link">CubeAxesActor</a><a href="Rendering_Core_Follower.html" class="mobile-nav-link">Follower</a><a href="Rendering_Core_Glyph3DMapper.html" class="mobile-nav-link">Glyph3DMapper</a><a href="Rendering_Core_HardwareSelector.html" class="mobile-nav-link">HardwareSelector</a><a href="Rendering_Core_ImageArrayMapper.html" class="mobile-nav-link">ImageArrayMapper</a><a href="Rendering_Core_ImageCPRMapper.html" class="mobile-nav-link">ImageCPRMapper</a><a href="Rendering_Core_ImageMapper.html" class="mobile-nav-link">ImageMapper</a><a href="Rendering_Core_ImageProperty.html" class="mobile-nav-link">ImageProperty</a><a href="Rendering_Core_ImageResliceMapper.html" class="mobile-nav-link">ImageResliceMapper</a><a href="Rendering_Core_ImageSlice.html" class="mobile-nav-link">ImageSlice</a><a href="Rendering_Core_InteractorObserver.html" class="mobile-nav-link">InteractorObserver</a><a href="Rendering_Core_InteractorStyle.html" class="mobile-nav-link">InteractorStyle</a><a href="Rendering_Core_Light.html" class="mobile-nav-link">Light</a><a href="Rendering_Core_Mapper.html" class="mobile-nav-link">Mapper</a><a href="Rendering_Core_Mapper2D.html" class="mobile-nav-link">Mapper2D</a><a href="Rendering_Core_Picker.html" class="mobile-nav-link">Picker</a><a href="Rendering_Core_PixelSpaceCallbackMapper.html" class="mobile-nav-link">PixelSpaceCallbackMapper</a><a href="Rendering_Core_PointPicker.html" class="mobile-nav-link">PointPicker</a><a href="Rendering_Core_Prop.html" class="mobile-nav-link">Prop</a><a href="Rendering_Core_Prop3D.html" class="mobile-nav-link">Prop3D</a><a href="Rendering_Core_Property.html" class="mobile-nav-link">Property</a><a href="Rendering_Core_Property2D.html" class="mobile-nav-link">Property2D</a><a href="Rendering_Core_RenderWindow.html" class="mobile-nav-link">RenderWindow</a><a href="Rendering_Core_RenderWindowInteractor.html" class="mobile-nav-link">RenderWindowInteractor</a><a href="Rendering_Core_Renderer.html" class="mobile-nav-link">Renderer</a><a href="Rendering_Core_ScalarBarActor.html" class="mobile-nav-link">ScalarBarActor</a><a href="Rendering_Core_Skybox.html" class="mobile-nav-link">Skybox</a><a href="Rendering_Core_SphereMapper.html" class="mobile-nav-link">SphereMapper</a><a href="Rendering_Core_StickMapper.html" class="mobile-nav-link">StickMapper</a><a href="Rendering_Core_SurfaceLICInterface.html" class="mobile-nav-link">SurfaceLICInterface</a><a href="Rendering_Core_SurfaceLICMapper.html" class="mobile-nav-link">SurfaceLICMapper</a><a href="Rendering_Core_Texture.html" class="mobile-nav-link">Texture</a><a href="Rendering_Core_Viewport.html" class="mobile-nav-link">Viewport</a><a href="Rendering_Core_Volume.html" class="mobile-nav-link">Volume</a><a href="Rendering_Core_VolumeMapper.html" class="mobile-nav-link">VolumeMapper</a><a href="Rendering_Core_VolumeProperty.html" class="mobile-nav-link">VolumeProperty</a><strong class="mobile-nav-title">Rendering/Misc</strong><a href="Rendering_Misc_CanvasView.html" class="mobile-nav-link">CanvasView</a><a href="Rendering_Misc_FullScreenRenderWindow.html" class="mobile-nav-link">FullScreenRenderWindow</a><a href="Rendering_Misc_GenericRenderWindow.html" class="mobile-nav-link">GenericRenderWindow</a><a href="Rendering_Misc_RemoteView.html" class="mobile-nav-link">RemoteView</a><a href="Rendering_Misc_RenderWindowWithControlBar.html" class="mobile-nav-link">RenderWindowWithControlBar</a><a href="Rendering_Misc_RenderingAPIs.html" class="mobile-nav-link">RenderingAPIs</a><a href="Rendering_Misc_SynchronizableRenderWindow.html" class="mobile-nav-link">SynchronizableRenderWindow</a><a href="Rendering_Misc_TextureLODsDownloader.html" class="mobile-nav-link">TextureLODsDownloader</a><strong class="mobile-nav-title">Rendering/OpenGL</strong><a href="Rendering_OpenGL_Actor.html" class="mobile-nav-link">Actor</a><a href="Rendering_OpenGL_Actor2D.html" class="mobile-nav-link">Actor2D</a><a href="Rendering_OpenGL_BufferObject.html" class="mobile-nav-link">BufferObject</a><a href="Rendering_OpenGL_Camera.html" class="mobile-nav-link">Camera</a><a href="Rendering_OpenGL_CellArrayBufferObject.html" class="mobile-nav-link">CellArrayBufferObject</a><a href="Rendering_OpenGL_Convolution2DPass.html" class="mobile-nav-link">Convolution2DPass</a><a href="Rendering_OpenGL_CubeAxesActor.html" class="mobile-nav-link">CubeAxesActor</a><a href="Rendering_OpenGL_ForwardPass.html" class="mobile-nav-link">ForwardPass</a><a href="Rendering_OpenGL_Framebuffer.html" class="mobile-nav-link">Framebuffer</a><a href="Rendering_OpenGL_Glyph3DMapper.html" class="mobile-nav-link">Glyph3DMapper</a><a href="Rendering_OpenGL_HardwareSelector.html" class="mobile-nav-link">HardwareSelector</a><a href="Rendering_OpenGL_Helper.html" class="mobile-nav-link">Helper</a><a href="Rendering_OpenGL_ImageCPRMapper.html" class="mobile-nav-link">ImageCPRMapper</a><a href="Rendering_OpenGL_ImageMapper.html" class="mobile-nav-link">ImageMapper</a><a href="Rendering_OpenGL_ImageResliceMapper.html" class="mobile-nav-link">ImageResliceMapper</a><a href="Rendering_OpenGL_ImageSlice.html" class="mobile-nav-link">ImageSlice</a><a href="Rendering_OpenGL_OrderIndependentTranslucentPass.html" class="mobile-nav-link">OrderIndependentTranslucentPass</a><a href="Rendering_OpenGL_PixelSpaceCallbackMapper.html" class="mobile-nav-link">PixelSpaceCallbackMapper</a><a href="Rendering_OpenGL_PolyDataMapper.html" class="mobile-nav-link">PolyDataMapper</a><a href="Rendering_OpenGL_PolyDataMapper2D.html" class="mobile-nav-link">PolyDataMapper2D</a><a href="Rendering_OpenGL_Profiles.html" class="mobile-nav-link">Profiles</a><a href="Rendering_OpenGL_RadialDistortionPass.html" class="mobile-nav-link">RadialDistortionPass</a><a href="Rendering_OpenGL_RenderWindow.html" class="mobile-nav-link">RenderWindow</a><a href="Rendering_OpenGL_Renderer.html" class="mobile-nav-link">Renderer</a><a href="Rendering_OpenGL_ReplacementShaderMapper.html" class="mobile-nav-link">ReplacementShaderMapper</a><a href="Rendering_OpenGL_ScalarBarActor.html" class="mobile-nav-link">ScalarBarActor</a><a href="Rendering_OpenGL_Shader.html" class="mobile-nav-link">Shader</a><a href="Rendering_OpenGL_ShaderCache.html" class="mobile-nav-link">ShaderCache</a><a href="Rendering_OpenGL_ShaderProgram.html" class="mobile-nav-link">ShaderProgram</a><a href="Rendering_OpenGL_Skybox.html" class="mobile-nav-link">Skybox</a><a href="Rendering_OpenGL_SphereMapper.html" class="mobile-nav-link">SphereMapper</a><a href="Rendering_OpenGL_StickMapper.html" class="mobile-nav-link">StickMapper</a><a href="Rendering_OpenGL_SurfaceLIC.html" class="mobile-nav-link">SurfaceLIC</a><a href="Rendering_OpenGL_Texture.html" class="mobile-nav-link">Texture</a><a href="Rendering_OpenGL_TextureUnitManager.html" class="mobile-nav-link">TextureUnitManager</a><a href="Rendering_OpenGL_VertexArrayObject.html" class="mobile-nav-link">VertexArrayObject</a><a href="Rendering_OpenGL_ViewNodeFactory.html" class="mobile-nav-link">ViewNodeFactory</a><a href="Rendering_OpenGL_Volume.html" class="mobile-nav-link">Volume</a><a href="Rendering_OpenGL_VolumeMapper.html" class="mobile-nav-link">VolumeMapper</a><a href="Rendering_OpenGL_glsl.html" class="mobile-nav-link">glsl</a><strong class="mobile-nav-title">Rendering/Profiles</strong><strong class="mobile-nav-title">Rendering/SceneGraph</strong><a href="Rendering_SceneGraph_RenderPass.html" class="mobile-nav-link">RenderPass</a><a href="Rendering_SceneGraph_RenderWindowViewNode.html" class="mobile-nav-link">RenderWindowViewNode</a><a href="Rendering_SceneGraph_ViewNode.html" class="mobile-nav-link">ViewNode</a><a href="Rendering_SceneGraph_ViewNodeFactory.html" class="mobile-nav-link">ViewNodeFactory</a><strong class="mobile-nav-title">Rendering/WebGPU</strong><a href="Rendering_WebGPU_Actor.html" class="mobile-nav-link">Actor</a><a href="Rendering_WebGPU_Actor2D.html" class="mobile-nav-link">Actor2D</a><a href="Rendering_WebGPU_BindGroup.html" class="mobile-nav-link">BindGroup</a><a href="Rendering_WebGPU_Buffer.html" class="mobile-nav-link">Buffer</a><a href="Rendering_WebGPU_BufferManager.html" class="mobile-nav-link">BufferManager</a><a href="Rendering_WebGPU_Camera.html" class="mobile-nav-link">Camera</a><a href="Rendering_WebGPU_CellArrayMapper.html" class="mobile-nav-link">CellArrayMapper</a><a href="Rendering_WebGPU_CubeAxesActor.html" class="mobile-nav-link">CubeAxesActor</a><a href="Rendering_WebGPU_Device.html" class="mobile-nav-link">Device</a><a href="Rendering_WebGPU_ForwardPass.html" class="mobile-nav-link">ForwardPass</a><a href="Rendering_WebGPU_FullScreenQuad.html" class="mobile-nav-link">FullScreenQuad</a><a href="Rendering_WebGPU_Glyph3DMapper.html" class="mobile-nav-link">Glyph3DMapper</a><a href="Rendering_WebGPU_HardwareSelectionPass.html" class="mobile-nav-link">HardwareSelectionPass</a><a href="Rendering_WebGPU_HardwareSelector.html" class="mobile-nav-link">HardwareSelector</a><a href="Rendering_WebGPU_ImageMapper.html" class="mobile-nav-link">ImageMapper</a><a href="Rendering_WebGPU_ImageSlice.html" class="mobile-nav-link">ImageSlice</a><a href="Rendering_WebGPU_IndexBuffer.html" class="mobile-nav-link">IndexBuffer</a><a href="Rendering_WebGPU_OpaquePass.html" class="mobile-nav-link">OpaquePass</a><a href="Rendering_WebGPU_OrderIndependentTranslucentPass.html" class="mobile-nav-link">OrderIndependentTranslucentPass</a><a href="Rendering_WebGPU_Pipeline.html" class="mobile-nav-link">Pipeline</a><a href="Rendering_WebGPU_PixelSpaceCallbackMapper.html" class="mobile-nav-link">PixelSpaceCallbackMapper</a><a href="Rendering_WebGPU_PolyDataMapper.html" class="mobile-nav-link">PolyDataMapper</a><a href="Rendering_WebGPU_PolyDataMapper2D.html" class="mobile-nav-link">PolyDataMapper2D</a><a href="Rendering_WebGPU_Profiles.html" class="mobile-nav-link">Profiles</a><a href="Rendering_WebGPU_RenderEncoder.html" class="mobile-nav-link">RenderEncoder</a><a href="Rendering_WebGPU_RenderWindow.html" class="mobile-nav-link">RenderWindow</a><a href="Rendering_WebGPU_Renderer.html" class="mobile-nav-link">Renderer</a><a href="Rendering_WebGPU_Sampler.html" class="mobile-nav-link">Sampler</a><a href="Rendering_WebGPU_ScalarBarActor.html" class="mobile-nav-link">ScalarBarActor</a><a href="Rendering_WebGPU_ShaderCache.html" class="mobile-nav-link">ShaderCache</a><a href="Rendering_WebGPU_ShaderDescription.html" class="mobile-nav-link">ShaderDescription</a><a href="Rendering_WebGPU_ShaderModule.html" class="mobile-nav-link">ShaderModule</a><a href="Rendering_WebGPU_SimpleMapper.html" class="mobile-nav-link">SimpleMapper</a><a href="Rendering_WebGPU_SphereMapper.html" class="mobile-nav-link">SphereMapper</a><a href="Rendering_WebGPU_StickMapper.html" class="mobile-nav-link">StickMapper</a><a href="Rendering_WebGPU_StorageBuffer.html" class="mobile-nav-link">StorageBuffer</a><a href="Rendering_WebGPU_Texture.html" class="mobile-nav-link">Texture</a><a href="Rendering_WebGPU_TextureManager.html" class="mobile-nav-link">TextureManager</a><a href="Rendering_WebGPU_TextureView.html" class="mobile-nav-link">TextureView</a><a href="Rendering_WebGPU_Types.html" class="mobile-nav-link">Types</a><a href="Rendering_WebGPU_UniformBuffer.html" class="mobile-nav-link">UniformBuffer</a><a href="Rendering_WebGPU_VertexInput.html" class="mobile-nav-link">VertexInput</a><a href="Rendering_WebGPU_ViewNodeFactory.html" class="mobile-nav-link">ViewNodeFactory</a><a href="Rendering_WebGPU_Volume.html" class="mobile-nav-link">Volume</a><a href="Rendering_WebGPU_VolumePass.html" class="mobile-nav-link">VolumePass</a><a href="Rendering_WebGPU_VolumePassFSQ.html" class="mobile-nav-link">VolumePassFSQ</a><strong class="mobile-nav-title">Rendering/WebXR</strong><a href="Rendering_WebXR_RenderWindowHelper.html" class="mobile-nav-link">RenderWindowHelper</a><strong class="mobile-nav-title">Testing/Examples</strong><a href="Testing_Examples_ActorSerialization.html" class="mobile-nav-link">ActorSerialization</a><a href="Testing_Examples_PipelineExecution.html" class="mobile-nav-link">PipelineExecution</a><a href="Testing_Examples_PolyDataSerialization.html" class="mobile-nav-link">PolyDataSerialization</a><a href="Testing_Examples_StandaloneSceneLoader.html" class="mobile-nav-link">StandaloneSceneLoader</a><a href="Testing_Examples_WindTunnel.html" class="mobile-nav-link">WindTunnel</a><strong class="mobile-nav-title">Widgets/Core</strong><a href="Widgets_Core_AbstractWidget.html" class="mobile-nav-link">AbstractWidget</a><a href="Widgets_Core_AbstractWidgetFactory.html" class="mobile-nav-link">AbstractWidgetFactory</a><a href="Widgets_Core_StateBuilder.html" class="mobile-nav-link">StateBuilder</a><a href="Widgets_Core_WidgetManager.html" class="mobile-nav-link">WidgetManager</a><a href="Widgets_Core_WidgetState.html" class="mobile-nav-link">WidgetState</a><strong class="mobile-nav-title">Widgets/Manipulators</strong><a href="Widgets_Manipulators_AbstractManipulator.html" class="mobile-nav-link">AbstractManipulator</a><a href="Widgets_Manipulators_CPRManipulator.html" class="mobile-nav-link">CPRManipulator</a><a href="Widgets_Manipulators_LineManipulator.html" class="mobile-nav-link">LineManipulator</a><a href="Widgets_Manipulators_PickerManipulator.html" class="mobile-nav-link">PickerManipulator</a><a href="Widgets_Manipulators_PlaneManipulator.html" class="mobile-nav-link">PlaneManipulator</a><a href="Widgets_Manipulators_TrackballManipulator.html" class="mobile-nav-link">TrackballManipulator</a><strong class="mobile-nav-title">Widgets/Representations</strong><a href="Widgets_Representations_ArrowHandleRepresentation.html" class="mobile-nav-link">ArrowHandleRepresentation</a><a href="Widgets_Representations_CircleContextRepresentation.html" class="mobile-nav-link">CircleContextRepresentation</a><a href="Widgets_Representations_ContextRepresentation.html" class="mobile-nav-link">ContextRepresentation</a><a href="Widgets_Representations_ConvexFaceContextRepresentation.html" class="mobile-nav-link">ConvexFaceContextRepresentation</a><a href="Widgets_Representations_CroppingOutlineRepresentation.html" class="mobile-nav-link">CroppingOutlineRepresentation</a><a href="Widgets_Representations_CubeHandleRepresentation.html" class="mobile-nav-link">CubeHandleRepresentation</a><a href="Widgets_Representations_GlyphRepresentation.html" class="mobile-nav-link">GlyphRepresentation</a><a href="Widgets_Representations_HandleRepresentation.html" class="mobile-nav-link">HandleRepresentation</a><a href="Widgets_Representations_ImplicitPlaneRepresentation.html" class="mobile-nav-link">ImplicitPlaneRepresentation</a><a href="Widgets_Representations_LineHandleRepresentation.html" class="mobile-nav-link">LineHandleRepresentation</a><a href="Widgets_Representations_OutlineContextRepresentation.html" class="mobile-nav-link">OutlineContextRepresentation</a><a href="Widgets_Representations_PolyLineRepresentation.html" class="mobile-nav-link">PolyLineRepresentation</a><a href="Widgets_Representations_RectangleContextRepresentation.html" class="mobile-nav-link">RectangleContextRepresentation</a><a href="Widgets_Representations_SphereContextRepresentation.html" class="mobile-nav-link">SphereContextRepresentation</a><a href="Widgets_Representations_SphereHandleRepresentation.html" class="mobile-nav-link">SphereHandleRepresentation</a><a href="Widgets_Representations_SplineContextRepresentation.html" class="mobile-nav-link">SplineContextRepresentation</a><a href="Widgets_Representations_WidgetRepresentation.html" class="mobile-nav-link">WidgetRepresentation</a><strong class="mobile-nav-title">Widgets/Widgets3D</strong><a href="Widgets_Widgets3D_AngleWidget.html" class="mobile-nav-link">AngleWidget</a><a href="Widgets_Widgets3D_EllipseWidget.html" class="mobile-nav-link">EllipseWidget</a><a href="Widgets_Widgets3D_ImageCroppingWidget.html" class="mobile-nav-link">ImageCroppingWidget</a><a href="Widgets_Widgets3D_ImplicitPlaneWidget.html" class="mobile-nav-link">ImplicitPlaneWidget</a><a href="Widgets_Widgets3D_InteractiveOrientationWidget.html" class="mobile-nav-link">InteractiveOrientationWidget</a><a href="Widgets_Widgets3D_LabelWidget.html" class="mobile-nav-link">LabelWidget</a><a href="Widgets_Widgets3D_LineWidget.html" class="mobile-nav-link">LineWidget</a><a href="Widgets_Widgets3D_PaintWidget.html" class="mobile-nav-link">PaintWidget</a><a href="Widgets_Widgets3D_PolyLineWidget.html" class="mobile-nav-link">PolyLineWidget</a><a href="Widgets_Widgets3D_RectangleWidget.html" class="mobile-nav-link">RectangleWidget</a><a href="Widgets_Widgets3D_ResliceCursorWidget.html" class="mobile-nav-link">ResliceCursorWidget</a><a href="Widgets_Widgets3D_SeedWidget.html" class="mobile-nav-link">SeedWidget</a><a href="Widgets_Widgets3D_ShapeWidget.html" class="mobile-nav-link">ShapeWidget</a><a href="Widgets_Widgets3D_SphereWidget.html" class="mobile-nav-link">SphereWidget</a><a href="Widgets_Widgets3D_SplineWidget.html" class="mobile-nav-link">SplineWidget</a>
    
  </div>
  <div id="mobile-lang-select-wrap">
    <span id="mobile-lang-select-label"><i class="fa fa-globe"></i><span>English</span></span>
    <select id="mobile-lang-select" data-canonical="api/Filters_General_ContourTriangulator.html">
      
        <option value="en" selected>English</option>
      
    </select>
  </div>
</nav>
  <!-- Scripts -->
<!-- build:js build/js/main.js -->

<script src="/vtk-js/js/lang_select.js"></script>


<script src="/vtk-js/js/toc.js"></script>


<script src="/vtk-js/js/mobile_nav.js"></script>

<!-- endbuild -->
<script src="https://cdn.jsdelivr.net/retinajs/1.3.0/retina.min.js" async></script>



</body>
</html>